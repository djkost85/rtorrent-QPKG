/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2210 from the
 * contents of SSLeay.xs. Do not edit this file, edit SSLeay.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "SSLeay.xs"
/* SSLeay.xs - Perl module for using Eric Young's implementation of SSL
 *
 * Copyright (c) 1996-2002 Sampo Kellomaki <sampo@iki.fi>
 * Copyright (C) 2005 Florian Ragwitz <rafl@debian.org>
 * Copyright (C) 2005 Mike McCauley <mikem@open.com.au>
 * 
 * All Rights Reserved.
 *
 * Change data removed. See Changes
 *
 * $Id: SSLeay.xs 378 2013-06-07 22:29:53Z mikem-guest $
 * 
 * The distribution and use of this module are subject to the conditions
 * listed in LICENSE file at the root of OpenSSL-0.9.6b
 * distribution (i.e. free, but mandatory attribution and NO WARRANTY).
 */

/* ####
 * #### PLEASE READ THE FOLLOWING RULES BEFORE YOU START EDITING THIS FILE! ####
 * ####
 *
 * Function naming conventions:
 *
 * 1/ never change the already existing function names (all calling convention) in a way
 *    that may cause backward incompatibility (e.g. add ALIAS with old name if necessary)
 *
 * 2/ it is recommended to keep the original openssl function names for functions that are:
 *
 *    1:1 wrappers to the original openssl functions
 *    see for example: X509_get_issuer_name(cert) >> Net::SSLeay::X509_get_issuer_name($cert)
 *
 *    nearly 1:1 wrappers implementing only necessary "glue" e.g. buffer handling
 *    see for example: RAND_seed(buf,len) >> Net::SSLeay::RAND_seed($buf)
 *
 * 3/ OpenSSL functions starting with "SSL_" are added into SSLeay.xs with "SLL_" prefix
 *    (e.g. SSL_CTX_new) but keep in mind that they will be available in Net::SSLeay without
 *    "SSL_" prefix (e.g. Net::SSLeay::CTX_new) - keep this for all new functions
 *
 * 4/ The names of functions which do not fit rule 2/ (which means they implement some non
 *    trivial code around original openssl function or do more complex tasks) should be
 *    prefixed with "P_" - see for example: P_ASN1_TIME_set_isotime
 *
 * 5/ Exceptions from rules above:
 *    functions that are part or wider set of already existing function not following this rule
 *    for example: there already exists: PEM_get_string_X509_CRL + PEM_get_string_X509_REQ and you want
 *    to add PEM_get_string_SOMETHING - then no need to follow 3/ (do not prefix with "P_")
 *
 * Support for different openssl versions, different platforms, different compilers:
 *
 * 1/ SSleay.xs is expected to build/pass test suite
 *    - with openssl 0.9.6 and newer versions
 *    - with perl 5.8 and newer versions
 *
 * 2/ Fix all compiler warnings - we expect 100% clean build
 *
 * 3/ If you add a function which is available since certain openssl version
 *    use proper #ifdefs to assure that SSLeay.xs will compile also with older versions
 *    which are missing this function
 *
 * 4/ Even warnings arising from different use of "const" in different openssl versions
 *    needs to be hanled with #ifdefs - see for example: X509_NAME_add_entry_by_txt
 *
 * 5/ avoid using global C variables (it is very likely to break thread-safetyness)
 *    use rather global MY_CXT structure
 *
 * 6/ avoid using any UNIX/POSIX specific functions, keep in mind that SSLeay.xs must
 *    compile also on non-UNIX platforms like MS Windows and others
 *
 * 7/ avoid using c++ comments "//" (or other c++ features accepted by some c compiler)
 *    even if your compiler can handle them without warnings
 *
 * Passing test suite:
 *
 * 1/ any changes to SSLeay.xs must not introduce a failure of existing test suite
 *
 * 2/ it is strongly recommended to create test(s) for newly added function(s), especially
 *    when the new function is not only a 1:1 wrapper but contains a complex code
 *
 * 3/ it is mandatory to add a documentation for all newly added functions into SSLeay.pod
 *    otherwise t/local/02_pod_coverage.t fail (and you will be asked to add some doc into
 *    your patch)
 *
 * Preferred code layout:
 *
 * 1/ for simple 1:1 XS wrappers use:
 *
 *    a/ functions with short "signature" (short list of args):
 *
 *    long
 *    SSL_set_tmp_dh(SSL *ssl,DH *dh)
 *
 *    b/ functions with long "signature" (long list of args):
 *       simply when approach a/ does not fit to 120 columns
 *
 *    void
 *    SSL_any_functions(library_flag,function_name,reason,file_name,line)
 *            int library_flag
 *            int function_name
 *            int reason
 *            char *file_name
 *            int line
 *
 * 2/ for XS functions with full implementation use identation like this:
 *
 *    int
 *    RAND_bytes(buf, num)
 *            SV *buf
 *            int num
 *        PREINIT:
 *            int rc;
 *            unsigned char *random;
 *        CODE:
 *            / * some code here * /
 *            RETVAL = rc;
 *        OUTPUT:
 *            RETVAL
 *
 * THE LAST RULE:
 *
 * The fact that some parts of SSLeay.xs do not follow the rules above is not 
 * a reason why any new code can also break these rules in the same way
 *
 */

/* Prevent warnings about strncpy from Windows compilers */
#define _CRT_SECURE_NO_DEPRECATE

#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#define NEED_newRV_noinc
#define NEED_sv_2pv_flags
#define NEED_my_snprintf
#include "ppport.h"
#ifdef __cplusplus
}
#endif

/* OpenSSL-0.9.3a has some strange warning about this in
 *    openssl/des.h
 */
#undef _

/* Sigh: openssl 1.0 has
 typedef void *BLOCK;
which conflicts with perls
 typedef struct block BLOCK;
*/
#define BLOCK OPENSSL_BLOCK
#include <openssl/err.h>
#include <openssl/lhash.h>
#include <openssl/rand.h>
#include <openssl/buffer.h>
#include <openssl/ssl.h>
#include <openssl/pkcs12.h>
#include <openssl/comp.h>    /* openssl-0.9.6a forgets to include this */
#ifndef OPENSSL_NO_MD2
#include <openssl/md2.h>
#endif
#include <openssl/md4.h>
#include <openssl/md5.h>     /* openssl-SNAP-20020227 does not automatically include this */
#if OPENSSL_VERSION_NUMBER >= 0x00905000L
#include <openssl/ripemd.h>
#endif
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#if OPENSSL_VERSION_NUMBER >= 0x0090700fL
/* requires 0.9.7+ */
#include <openssl/engine.h>
#endif
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif
#undef BLOCK

/* Debugging output - to enable use:
 *
 * perl Makefile.PL DEFINE=-DSHOW_XS_DEBUG
 * make
 *
 */

#ifdef SHOW_XS_DEBUG
#define PR1(s) fprintf(stderr,s);
#define PR2(s,t) fprintf(stderr,s,t);
#define PR3(s,t,u) fprintf(stderr,s,t,u);
#define PR4(s,t,u,v) fprintf(stderr,s,t,u,v);
#else
#define PR1(s)
#define PR2(s,t)
#define PR3(s,t,u)
#define PR4(s,t,u,v)
#endif

#include "constants.c"

/* ============= thread-safety related stuff ============== */

#define MY_CXT_KEY "Net::SSLeay::_guts" XS_VERSION

typedef struct {
    HV* global_cb_data;
    UV tid;
} my_cxt_t;
START_MY_CXT

#ifdef USE_ITHREADS
static perl_mutex LIB_init_mutex;
static perl_mutex *GLOBAL_openssl_mutex = NULL;
#endif
static int LIB_initialized;

UV get_my_thread_id(void) /* returns threads->tid() value */
{
    dSP;
    UV tid = 0;
    int count = 0;

#ifdef USE_ITHREADS
    ENTER;
    SAVETMPS;
    PUSHMARK(SP);
    XPUSHs(sv_2mortal(newSVpv("threads", 0)));
    PUTBACK;
    count = call_method("tid", G_SCALAR|G_EVAL);
    SPAGAIN;
    if (SvTRUE(ERRSV) || count != 1)
       /* if threads not loaded or an error occurs return 0 */
       tid = 0;
    else
       tid = (UV)POPi;
    PUTBACK;
    FREETMPS;
    LEAVE;
#endif

    return tid;
}

/* IMPORTANT NOTE:
 * openssl locking was implemented according to http://www.openssl.org/docs/crypto/threads.html
 * we implement both static and dynamic locking as described on URL above
 * locking is supported when OPENSSL_THREADS macro is defined which means openssl-0.9.7 or newer
 * we intentionally do not implement cleanup of openssl's threading as it causes troubles
 * with apache-mpm-worker+mod_perl+mod_ssl+net-ssleay
 */
#if defined(USE_ITHREADS) && defined(OPENSSL_THREADS)

static void openssl_locking_function(int mode, int type, const char *file, int line)
{
    PR3("openssl_locking_function %d %d\n", mode, type);

    if (!GLOBAL_openssl_mutex) return;
    if (mode & CRYPTO_LOCK)
      MUTEX_LOCK(&GLOBAL_openssl_mutex[type]);
    else
      MUTEX_UNLOCK(&GLOBAL_openssl_mutex[type]);
}

#if OPENSSL_VERSION_NUMBER < 0x10000000L
static unsigned long openssl_threadid_func(void)
{
    dMY_CXT;
    return (unsigned long)(MY_CXT.tid);
}
#else
void openssl_threadid_func(CRYPTO_THREADID *id)
{
    dMY_CXT;
    CRYPTO_THREADID_set_numeric(id, (unsigned long)(MY_CXT.tid));
}
#endif

struct CRYPTO_dynlock_value
{
    perl_mutex mutex;
};

struct CRYPTO_dynlock_value * openssl_dynlocking_create_function (const char *file, int line)
{
    struct CRYPTO_dynlock_value *retval;
    New(0, retval, 1, struct CRYPTO_dynlock_value);
    if (!retval) return NULL;
    MUTEX_INIT(&retval->mutex);
    return retval;
}

void openssl_dynlocking_lock_function (int mode, struct CRYPTO_dynlock_value *l, const char *file, int line)
{
    if (!l) return;
    if (mode & CRYPTO_LOCK)
      MUTEX_LOCK(&l->mutex);
    else
      MUTEX_UNLOCK(&l->mutex);
}

void openssl_dynlocking_destroy_function (struct CRYPTO_dynlock_value *l, const char *file, int line)
{
    if (!l) return;
    MUTEX_DESTROY(&l->mutex);
    Safefree(l);
}

void openssl_threads_init(void)
{
    int i;

    PR1("STARTED: openssl_threads_init\n");

    /* initialize static locking */
    if ( !CRYPTO_get_locking_callback() ) {
#if OPENSSL_VERSION_NUMBER < 0x10000000L
        if ( !CRYPTO_get_id_callback() ) {
#else
        if ( !CRYPTO_THREADID_get_callback() ) {
#endif
            PR2("openssl_threads_init static locking %d\n", CRYPTO_num_locks());
            New(0, GLOBAL_openssl_mutex, CRYPTO_num_locks(), perl_mutex);
            if (!GLOBAL_openssl_mutex) return;
            for (i=0; i<CRYPTO_num_locks(); i++) MUTEX_INIT(&GLOBAL_openssl_mutex[i]);
            CRYPTO_set_locking_callback((void (*)(int,int,const char *,int))openssl_locking_function);

#ifndef WIN32
            /* no need for threadid_func() on Win32 */
#if OPENSSL_VERSION_NUMBER < 0x10000000L
            CRYPTO_set_id_callback(openssl_threadid_func);
#else
            CRYPTO_THREADID_set_callback(openssl_threadid_func);
#endif
#endif
        }
    }

    /* initialize dynamic locking */
    if ( !CRYPTO_get_dynlock_create_callback() &&
         !CRYPTO_get_dynlock_lock_callback() &&
         !CRYPTO_get_dynlock_destroy_callback() ) {
        PR1("openssl_threads_init dynamic locking\n");
        CRYPTO_set_dynlock_create_callback(openssl_dynlocking_create_function);
        CRYPTO_set_dynlock_lock_callback(openssl_dynlocking_lock_function);
        CRYPTO_set_dynlock_destroy_callback(openssl_dynlocking_destroy_function);
    }
}

#endif

/* ============= typedefs to agument TYPEMAP ============== */

typedef void callback_no_ret(void);
typedef void cb_ssl_int_int_ret_void(const SSL *ssl,int,int);
typedef RSA * cb_ssl_int_int_ret_RSA(SSL * ssl,int is_export, int keylength);
typedef DH * cb_ssl_int_int_ret_DH(SSL * ssl,int is_export, int keylength);

typedef STACK_OF(X509_NAME) X509_NAME_STACK;

typedef int perl_filehandle_t;

/* ======= special handler used by EVP_MD_do_all_sorted ======= */

#if OPENSSL_VERSION_NUMBER >= 0x1000000fL
static void handler_list_md_fn(const EVP_MD *m, const char *from, const char *to, void *arg)
{
  /* taken from apps/dgst.c */
  const char *mname;
  if (!m) return;                                           /* Skip aliases */
  mname = OBJ_nid2ln(EVP_MD_type(m));
  if (strcmp(from, mname)) return;                          /* Skip shortnames */
  if (EVP_MD_flags(m) & EVP_MD_FLAG_PKEY_DIGEST) return;    /* Skip clones */
  if (strchr(mname, ' ')) mname= EVP_MD_name(m);
  av_push(arg, newSVpv(mname,0));
}
#endif

/* ============= callbacks - basic info =============
 *
 * PLEASE READ THIS BEFORE YOU ADD ANY NEW CALLBACK!!
 *
 * There are basically 2 types of callbacks used in SSLeay:
 *
 * 1/ "one-time" callbacks - these are created+used+destroyed within one perl function implemented in XS
 *    these callbacks use a cpecial C structupe simple_cb_data_t to pass necessary data
 *    there are 2 related helper functions: simple_cb_data_new() + simple_cb_data_free
 *    for example see implementation of these functions:
 *    - RSA_generate_key
 *    - PEM_read_bio_PrivateKey
 *
 * 2/ "advanced" callbacks - these are setup/destroyed by one function but used by another function; these
 *    callbacks use global hash MY_CXT.global_cb_data to store perl functions + data to be uset at callback time
 *    there are 2 related helper functions: cb_data_advanced_put() + cb_data_advanced_get for manipulating
 *    global hash MY_CXT.global_cb_data which work like this:
 *        cb_data_advanced_put(<pointer>, "data_name", dataSV)
 *        >>>
 *        global_cb_data->{"ptr_<pointer>"}->{"data_name"} = dataSV)
 *    or
 *        data = cb_data_advanced_get(<pointer>, "data_name")
 *        >>>
 *        my $data = global_cb_data->{"ptr_<pointer>"}->{"data_name"}
 *    for example see implementation of these functions:
 *    - SSL_CTX_set_verify
 *    - SSL_set_verify
 *    - SSL_CTX_set_cert_verify_callback
 *    - SSL_CTX_set_default_passwd_cb
 *    - SSL_CTX_set_default_passwd_cb_userdata
 *    - SSL_set_session_secret_cb
 *
 * If you want to add a new callback:
 * - you very likely need a new function "your_callback_name_invoke()"
 * - decide whether your case fits case 1/ or 2/ (and implement likewise existing functions)
 * - try to avoid adding a new style of callback implementation (or ask Net::SSLeay maintainers before)
 *
 */

/* ============= callback stuff - generic functions============== */

struct _ssleay_cb_t {
    SV* func;
    SV* data;
};
typedef struct _ssleay_cb_t simple_cb_data_t;

simple_cb_data_t* simple_cb_data_new(SV* func, SV* data)
{
    simple_cb_data_t* cb;
    New(0, cb, 1, simple_cb_data_t);
    if (cb) {
        SvREFCNT_inc(func);
        SvREFCNT_inc(data);
        cb->func = func;
        cb->data = data;
    }
    return cb;
}

void simple_cb_data_free(simple_cb_data_t* cb)
{
    if (cb) {
        if (cb->func) {
            SvREFCNT_dec(cb->func);
            cb->func = NULL;
        }
        if (cb->data) {
            SvREFCNT_dec(cb->data);
            cb->data = NULL;
        }
    }
    Safefree(cb);
}

int cb_data_advanced_put(void *ptr, const char* data_name, SV* data)
{
    HV * L2HV;
    SV ** svtmp;
    int len;
    char key_name[500];
    dMY_CXT;

    len = my_snprintf(key_name, sizeof(key_name), "ptr_%p", ptr);
    if (len == sizeof(key_name)) return 0; /* error  - key_name too short*/

    /* get or create level-2 hash */
    svtmp = hv_fetch(MY_CXT.global_cb_data, key_name, strlen(key_name), 0);
    if (svtmp == NULL) {
        L2HV = newHV();
        hv_store(MY_CXT.global_cb_data, key_name, strlen(key_name), newRV_noinc((SV*)L2HV), 0);
    }
    else {
        if (!SvOK(*svtmp) || !SvROK(*svtmp)) return 0;
#if defined(MUTABLE_PTR)
        L2HV = (HV*)MUTABLE_PTR(SvRV(*svtmp));
#else
        L2HV = (HV*)(SvRV(*svtmp));
#endif
    }

    /* first delete already stored value */
    hv_delete(L2HV, data_name, strlen(data_name), G_DISCARD);
    if (data!=NULL)
        if (SvOK(data))
            hv_store(L2HV, data_name, strlen(data_name), data, 0);

    return 1;
}

SV* cb_data_advanced_get(void *ptr, const char* data_name)
{
    HV * L2HV;
    SV ** svtmp;
    int len;
    char key_name[500];
    dMY_CXT;

    len = my_snprintf(key_name, sizeof(key_name), "ptr_%p", ptr);
    if (len == sizeof(key_name)) return &PL_sv_undef; /* return undef on error - key_name too short*/

    /* get level-2 hash */
    svtmp = hv_fetch(MY_CXT.global_cb_data, key_name, strlen(key_name), 0);
    if (svtmp == NULL)  return &PL_sv_undef;
    if (!SvOK(*svtmp))  return &PL_sv_undef;
    if (!SvROK(*svtmp)) return &PL_sv_undef;
#if defined(MUTABLE_PTR)
    L2HV = (HV*)MUTABLE_PTR(SvRV(*svtmp));
#else
    L2HV = (HV*)(SvRV(*svtmp));
#endif

    /* get stored data */
    svtmp = hv_fetch(L2HV, data_name, strlen(data_name), 0);
    if (svtmp == NULL) return &PL_sv_undef;
    if (!SvOK(*svtmp)) return &PL_sv_undef;

    return *svtmp;
}

int cb_data_advanced_drop(void *ptr)
{
    int len;
    char key_name[500];
    dMY_CXT;

    len = my_snprintf(key_name, sizeof(key_name), "ptr_%p", ptr);
    if (len == sizeof(key_name)) return 0; /* error  - key_name too short*/

    hv_delete(MY_CXT.global_cb_data, key_name, strlen(key_name), G_DISCARD);
    return 1;
}

/* ============= callback stuff - invoke functions ============== */

static int ssleay_verify_callback_invoke (int ok, X509_STORE_CTX* x509_store)
{
    dSP;
    SSL* ssl;
    int count = -1, res;
    SV *cb_func;

    PR1("STARTED: ssleay_verify_callback_invoke\n");
    ssl = X509_STORE_CTX_get_ex_data(x509_store, SSL_get_ex_data_X509_STORE_CTX_idx());
    cb_func = cb_data_advanced_get(ssl, "ssleay_verify_callback!!func");
    
    if (!SvOK(cb_func)) {
        SSL_CTX* ssl_ctx = SSL_get_SSL_CTX(ssl);
        cb_func = cb_data_advanced_get(ssl_ctx, "ssleay_verify_callback!!func");
     }
 
    if (!SvOK(cb_func))
        croak("Net::SSLeay: verify_callback called, but not set to point to any perl function.\n");

    ENTER;
    SAVETMPS;

    PR2("verify callback glue ok=%d\n", ok);

    PUSHMARK(sp);
    EXTEND( sp, 2 );
    PUSHs( sv_2mortal(newSViv(ok)) );
    PUSHs( sv_2mortal(newSViv(PTR2IV(x509_store))) );
    PUTBACK;

    PR1("About to call verify callback.\n");
    count = call_sv(cb_func, G_SCALAR);
    PR1("Returned from verify callback.\n");

    SPAGAIN;

    if (count != 1)
        croak ( "Net::SSLeay: verify_callback perl function did not return a scalar.\n");

    res = POPi;

    PUTBACK;
    FREETMPS;
    LEAVE;

    return res;
}

static int ssleay_ctx_passwd_cb_invoke(char *buf, int size, int rwflag, void *userdata)
{
    dSP;
    int count = -1;
    char *res;
    SV *cb_func, *cb_data;

    PR1("STARTED: ssleay_ctx_passwd_cb_invoke\n");
    cb_func = cb_data_advanced_get(userdata, "ssleay_ctx_passwd_cb!!func");
    cb_data = cb_data_advanced_get(userdata, "ssleay_ctx_passwd_cb!!data");

    if(!SvOK(cb_func))
        croak ("Net::SSLeay: ssleay_ctx_passwd_cb_invoke called, but not set to point to any perl function.\n");

    ENTER;
    SAVETMPS;

    PUSHMARK(sp);
    XPUSHs(sv_2mortal(newSViv(rwflag)));
    XPUSHs(sv_2mortal(newSVsv(cb_data)));
    PUTBACK;

    count = call_sv( cb_func, G_SCALAR );

    SPAGAIN;

    if (count != 1)
        croak("Net::SSLeay: ssleay_ctx_passwd_cb_invoke perl function did not return a scalar.\n");

    res = POPp;

    if (res == NULL) {
        *buf = '\0';
    } else {
        strncpy(buf, res, size);
        buf[size - 1] = '\0';
    }

    PUTBACK;
    FREETMPS;
    LEAVE;

    return strlen(buf);
}

int ssleay_ctx_cert_verify_cb_invoke(X509_STORE_CTX* x509_store_ctx, void* data)
{
    dSP;
    int count = -1;
    int res;
    SV * cb_func, *cb_data;
    void *ptr;
    SSL *ssl;

    PR1("STARTED: ssleay_ctx_cert_verify_cb_invoke\n");
#if OPENSSL_VERSION_NUMBER < 0x0090700fL
    ssl = X509_STORE_CTX_get_ex_data(x509_store_ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
    ptr = (void*) SSL_get_SSL_CTX(ssl);
#else
    ssl = NULL;
    ptr = (void*) data;
#endif

    cb_func = cb_data_advanced_get(ptr, "ssleay_ctx_cert_verify_cb!!func");
    cb_data = cb_data_advanced_get(ptr, "ssleay_ctx_cert_verify_cb!!data");

    if(!SvOK(cb_func))
        croak ("Net::SSLeay: ssleay_ctx_cert_verify_cb_invoke called, but not set to point to any perl function.\n");

    ENTER;
    SAVETMPS;

    PUSHMARK(SP);
    XPUSHs(sv_2mortal(newSViv(PTR2IV(x509_store_ctx))));
    XPUSHs(sv_2mortal(newSVsv(cb_data)));
    PUTBACK;

    count = call_sv(cb_func, G_SCALAR);

    SPAGAIN;

    if (count != 1)
        croak("Net::SSLeay: ssleay_ctx_cert_verify_cb_invoke perl function did not return a scalar.\n");

    res = POPi;

    PUTBACK;
    FREETMPS;
    LEAVE;

    return res;
}

#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)

int tlsext_servername_callback_invoke(SSL *ssl, int *ad, void *arg)
{
    dSP;
    int count = -1;
    int res;
    SV * cb_func, *cb_data;

    PR1("STARTED: tlsext_servername_callback_invoke\n");

    cb_func = cb_data_advanced_get(arg, "tlsext_servername_callback!!func");
    cb_data = cb_data_advanced_get(arg, "tlsext_servername_callback!!data");

    if(!SvOK(cb_func))
        croak ("Net::SSLeay: tlsext_servername_callback_invoke called, but not set to point to any perl function.\n");

    ENTER;
    SAVETMPS;

    PUSHMARK(SP);
    XPUSHs(sv_2mortal(newSViv(PTR2IV(ssl))));
    XPUSHs(sv_2mortal(newSVsv(cb_data)));
    PUTBACK;

    count = call_sv(cb_func, G_SCALAR);

    SPAGAIN;

    if (count != 1)
        croak("Net::SSLeay: tlsext_servername_callback_invoke perl function did not return a scalar.\n");

    res = POPi;

    PUTBACK;
    FREETMPS;
    LEAVE;

    return res;
}

#endif

#if defined(SSL_F_SSL_SET_HELLO_EXTENSION) || defined(SSL_F_SSL_SET_SESSION_TICKET_EXT)

int ssleay_session_secret_cb_invoke(SSL* s, void* secret, int *secret_len,
                                    STACK_OF(SSL_CIPHER) *peer_ciphers,
                                    SSL_CIPHER **cipher, void *arg)
{
    dSP;
    int count = -1, res, i;
    AV *ciphers = newAV();
    SV *pref_cipher = sv_newmortal();
    SV * cb_func, *cb_data;

    PR1("STARTED: ssleay_session_secret_cb_invoke\n");
    cb_func = cb_data_advanced_get(arg, "ssleay_session_secret_cb!!func");
    cb_data = cb_data_advanced_get(arg, "ssleay_session_secret_cb!!data");

    if(!SvOK(cb_func))
        croak ("Net::SSLeay: ssleay_ctx_passwd_cb_invoke called, but not set to point to any perl function.\n");

    ENTER;
    SAVETMPS;

    PUSHMARK(SP);

    XPUSHs( sv_2mortal( newSVpv(secret, *secret_len)) );
    for (i=0; i<sk_SSL_CIPHER_num(peer_ciphers); i++) {
        SSL_CIPHER *c = sk_SSL_CIPHER_value(peer_ciphers,i);
        av_store(ciphers, i, sv_2mortal(newSVpv(SSL_CIPHER_get_name(c), 0)));
    }
    XPUSHs(sv_2mortal(newRV_inc((SV*)ciphers)));
    XPUSHs(sv_2mortal(newRV_inc(pref_cipher)));
    XPUSHs(sv_2mortal(newSVsv(cb_data)));

    PUTBACK;

    count = call_sv( cb_func, G_SCALAR );

    SPAGAIN;

    if (count != 1)
        croak ("Net::SSLeay: ssleay_session_secret_cb_invoke perl function did not return a scalar.\n");

    res = POPi;
    if (res) {
        /* See if there is a preferred cipher selected, if so it is an index into the stack */
        if (SvIOK(pref_cipher))
            *cipher = sk_SSL_CIPHER_value(peer_ciphers, SvIV(pref_cipher));
    }

    PUTBACK;
    FREETMPS;
    LEAVE;

    return res;
}

#endif

#if OPENSSL_VERSION_NUMBER >= 0x10001000L && !defined(OPENSSL_NO_NEXTPROTONEG)

int next_proto_helper_AV2protodata(AV * list, unsigned char *out)
{
    int i, last_index, ptr = 0;
    last_index = av_len(list);
    if (last_index<0) return 0;
    for(i=0; i<=last_index; i++) {
        char *p = SvPV_nolen(*av_fetch(list, i, 0));
        int len = strlen(p);
        if (len<0 || len>255) return 0;
        if (out) {
            /* if out == NULL we only calculate the length of output */
            out[ptr] = (unsigned char)len;
            strncpy((char*)out+ptr+1, p, len);
        }
        ptr += strlen(p) + 1;
    }
    return ptr;
}

int next_proto_helper_protodata2AV(AV * list, const unsigned char *in, unsigned int inlen)
{
    unsigned int i = 0;
    unsigned char il;
    if (!list || inlen<2) return 0;   
    while (i<inlen) {
        il = in[i++];
        if (i+il > inlen) return 0;
        av_push(list, newSVpv((const char*)in+i, il));
        i += il;
    }
    return 1;
}

int next_proto_select_cb_invoke(SSL *ssl, unsigned char **out, unsigned char *outlen,
                                const unsigned char *in, unsigned int inlen, void *arg)
{
    SV *cb_func, *cb_data;
    unsigned char *next_proto_data;
    unsigned char next_proto_len;
    int next_proto_status;
    SSL_CTX *ctx = SSL_get_SSL_CTX(ssl);
    STRLEN n_a;

    PR1("STARTED: next_proto_select_cb_invoke\n");
    cb_func = cb_data_advanced_get(ctx, "next_proto_select_cb!!func");
    cb_data = cb_data_advanced_get(ctx, "next_proto_select_cb!!data");
    /* clear last_status value = store undef */
    cb_data_advanced_put(ssl, "next_proto_select_cb!!last_status", NULL);
    cb_data_advanced_put(ssl, "next_proto_select_cb!!last_negotiated", NULL);

    if (SvROK(cb_func) && (SvTYPE(SvRV(cb_func)) == SVt_PVCV)) {
        int count = -1;
        AV *list = newAV();
        SV *tmpsv;
        dSP;
        
        if (!next_proto_helper_protodata2AV(list, in, inlen)) return SSL_TLSEXT_ERR_ALERT_FATAL;

        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSViv(PTR2IV(ssl))));
        XPUSHs(sv_2mortal(newRV_inc((SV*)list)));
        XPUSHs(sv_2mortal(newSVsv(cb_data)));
        PUTBACK;
        count = call_sv( cb_func, G_ARRAY );
        SPAGAIN;
        if (count != 2)
            croak ("Net::SSLeay: next_proto_select_cb_invoke perl function did not return 2 values.\n");
        next_proto_data = (unsigned char*)POPpx;
        next_proto_status = POPi;
        PUTBACK;
        FREETMPS;
        LEAVE;

        if (strlen((const char*)next_proto_data)>255) return SSL_TLSEXT_ERR_ALERT_FATAL;
        next_proto_len = strlen((const char*)next_proto_data);
        /* store last_status + last_negotiated into global hash */
        cb_data_advanced_put(ssl, "next_proto_select_cb!!last_status", newSViv(next_proto_status));
        tmpsv = newSVpv((const char*)next_proto_data, next_proto_len);
        cb_data_advanced_put(ssl, "next_proto_select_cb!!last_negotiated", tmpsv);
        *out = (unsigned char *)SvPVX(tmpsv);
        *outlen = next_proto_len;
        return SSL_TLSEXT_ERR_OK;
    }
    else if (SvROK(cb_data) && (SvTYPE(SvRV(cb_data)) == SVt_PVAV)) {
        next_proto_len = next_proto_helper_AV2protodata((AV*)SvRV(cb_data), NULL);
        Newx(next_proto_data, next_proto_len, unsigned char);
        if (!next_proto_data) return SSL_TLSEXT_ERR_ALERT_FATAL;
        next_proto_len = next_proto_helper_AV2protodata((AV*)SvRV(cb_data), next_proto_data);

        next_proto_status = SSL_select_next_proto(out, outlen, in, inlen, next_proto_data, next_proto_len);

        /* store last_status + last_negotiated into global hash */
        cb_data_advanced_put(ssl, "next_proto_select_cb!!last_status", newSViv(next_proto_status));
        cb_data_advanced_put(ssl, "next_proto_select_cb!!last_negotiated", newSVpv((const char*)*out, *outlen));
        Safefree(next_proto_data);
        return SSL_TLSEXT_ERR_OK;
    }
    return SSL_TLSEXT_ERR_ALERT_FATAL;
}

int next_protos_advertised_cb_invoke(SSL *ssl, const unsigned char **out, unsigned int *outlen, void *arg_unused)
{
    SV *cb_func, *cb_data;
    unsigned char *protodata = NULL;
    unsigned short protodata_len = 0;
    SV *tmpsv;
    AV *tmpav;
    SSL_CTX *ctx = SSL_get_SSL_CTX(ssl);

    PR1("STARTED: next_protos_advertised_cb_invoke");
    cb_func = cb_data_advanced_get(ctx, "next_protos_advertised_cb!!func");
    cb_data = cb_data_advanced_get(ctx, "next_protos_advertised_cb!!data");

    if (SvROK(cb_func) && (SvTYPE(SvRV(cb_func)) == SVt_PVCV)) {
        int count = -1;
        dSP;
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSViv(PTR2IV(ssl))));
        XPUSHs(sv_2mortal(newSVsv(cb_data)));
        PUTBACK;
        count = call_sv( cb_func, G_SCALAR );
        SPAGAIN;
        if (count != 1)
            croak ("Net::SSLeay: next_protos_advertised_cb_invoke perl function did not return scalar value.\n");
        tmpsv = POPs;
        if (SvOK(tmpsv) && SvROK(tmpsv) && (SvTYPE(SvRV(tmpsv)) == SVt_PVAV)) {
            tmpav = (AV*)SvRV(tmpsv);
            protodata_len = next_proto_helper_AV2protodata(tmpav, NULL);
            Newx(protodata, protodata_len, unsigned char);
            if (protodata) next_proto_helper_AV2protodata(tmpav, protodata);
        }
        PUTBACK;
        FREETMPS;
        LEAVE;
    }
    else if (SvROK(cb_data) && (SvTYPE(SvRV(cb_data)) == SVt_PVAV)) {
        tmpav = (AV*)SvRV(cb_data);
        protodata_len = next_proto_helper_AV2protodata(tmpav, NULL);
        Newx(protodata, protodata_len, unsigned char);
        if (protodata) next_proto_helper_AV2protodata(tmpav, protodata);
    }    
    if (protodata) {
        tmpsv = newSVpv((const char*)protodata, protodata_len);
        Safefree(protodata);
        cb_data_advanced_put(ssl, "next_protos_advertised_cb!!last_advertised", tmpsv);
        *out = (unsigned char *)SvPVX(tmpsv);
        *outlen = protodata_len;
        return SSL_TLSEXT_ERR_OK;
    }
    return SSL_TLSEXT_ERR_ALERT_FATAL;
}

#endif

int pem_password_cb_invoke(char *buf, int bufsize, int rwflag, void *data) {
    dSP;
    char *str;
    int count = -1, str_len = 0;
    simple_cb_data_t* cb = (simple_cb_data_t*)data;
    STRLEN n_a;

    PR1("STARTED: pem_password_cb_invoke\n");
    if (cb->func && SvOK(cb->func)) {
        ENTER;
        SAVETMPS;

        PUSHMARK(sp);

        XPUSHs(sv_2mortal( newSViv(bufsize-1) ));
        XPUSHs(sv_2mortal( newSViv(rwflag) ));
        if (cb->data) XPUSHs( cb->data );

        PUTBACK;

        count = call_sv( cb->func, G_SCALAR );

        SPAGAIN;

        buf[0] = 0; /* start with an empty password */
        if (count != 1) {
            croak("Net::SSLeay: pem_password_cb_invoke perl function did not return a scalar.\n");
        }
        else {
            str = POPpx;
            str_len = strlen(str);
            if (str_len+1 < bufsize) {
                strcpy(buf, str);
            }
            else {
                str_len = 0;
                warn("Net::SSLeay: pem_password_cb_invoke password too long\n");
            }
        }

        PUTBACK;
        FREETMPS;
        LEAVE;
    }
    return str_len;
}

void ssleay_RSA_generate_key_cb_invoke(int i, int n, void* data)
{
    dSP;
    int count = -1;
    simple_cb_data_t* cb = (simple_cb_data_t*)data;

    /* PR1("STARTED: ssleay_RSA_generate_key_cb_invoke\n"); / * too noisy */
    if (cb->func && SvOK(cb->func)) {
        ENTER;
        SAVETMPS;

        PUSHMARK(sp);

        XPUSHs(sv_2mortal( newSViv(i) ));
        XPUSHs(sv_2mortal( newSViv(n) ));
        if (cb->data) XPUSHs( cb->data );

        PUTBACK;

        count = call_sv( cb->func, G_VOID|G_DISCARD );

        if (count != 0)
            croak ("Net::SSLeay: ssleay_RSA_generate_key_cb_invoke "
                   "perl function did return something in void context.\n");

        PUTBACK;
        FREETMPS;
        LEAVE;
    }
}

/* ============= end of callback stuff ============== */

#line 1024 "SSLeay.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 1076 "SSLeay.c"

XS(XS_Net__SSLeay_CLONE); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CLONE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 1042 "SSLeay.xs"
    MY_CXT_CLONE;
    /* reset all callback related data as we want to prevent 
     * cross-thread callbacks
     * TODO: later somebody can make the global hash MY_CXT.global_cb_data
     * somehow shared between threads
     */
    MY_CXT.global_cb_data = newHV();
    MY_CXT.tid = get_my_thread_id();
    PR3("CLONE: tid=%d my_perl=0x%p\n", MY_CXT.tid, my_perl);
#line 1098 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_constant)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	char *	name = (char *)SvPV_nolen(ST(0));
	double	RETVAL;
	dXSTARG;
#line 1056 "SSLeay.xs"
        errno = 0;
        RETVAL = constant(name, strlen(name));
#line 1121 "SSLeay.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_hello); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_hello)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 1064 "SSLeay.xs"
        PR1("\tSSLeay Hello World!\n");
        RETVAL = 1;
#line 1144 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define REM0 "============= version related functions =============="

XS(XS_Net__SSLeay_SSLeay); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SSLeay)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	unsigned long	RETVAL;
	dXSTARG;

	RETVAL = SSLeay();
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SSLeay_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SSLeay_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "type=0");
    {
	int	type;
	const char *	RETVAL;
	dXSTARG;

	if (items < 1)
	    type = 0;
	else {
	    type = (int)SvIV(ST(0));
	}

	RETVAL = SSLeay_version(type);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#define REM1 "============= SSL CONTEXT functions =============="

XS(XS_Net__SSLeay_CTX_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SSL_CTX *	RETVAL;
	dXSTARG;
#line 1083 "SSLeay.xs"
     RETVAL = SSL_CTX_new (SSLv23_method());
#line 1217 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#ifndef OPENSSL_NO_SSL2
#if OPENSSL_VERSION_NUMBER < 0x10000000L
#define XSubPPtmpAAAA 1


XS(XS_Net__SSLeay_CTX_v2_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_v2_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SSL_CTX *	RETVAL;
	dXSTARG;
#line 1093 "SSLeay.xs"
     RETVAL = SSL_CTX_new (SSLv2_method());
#line 1243 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#endif
#endif

XS(XS_Net__SSLeay_CTX_v3_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_v3_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SSL_CTX *	RETVAL;
	dXSTARG;
#line 1103 "SSLeay.xs"
     RETVAL = SSL_CTX_new (SSLv3_method());
#line 1267 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_v23_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_v23_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SSL_CTX *	RETVAL;
	dXSTARG;
#line 1110 "SSLeay.xs"
     RETVAL = SSL_CTX_new (SSLv23_method());
#line 1289 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_tlsv1_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_tlsv1_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SSL_CTX *	RETVAL;
	dXSTARG;
#line 1117 "SSLeay.xs"
     RETVAL = SSL_CTX_new (TLSv1_method());
#line 1311 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#ifdef SSL_TXT_TLSV1_1
#define XSubPPtmpAAAB 1


XS(XS_Net__SSLeay_CTX_tlsv1_1_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_tlsv1_1_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SSL_CTX *	RETVAL;
	dXSTARG;
#line 1126 "SSLeay.xs"
     RETVAL = SSL_CTX_new (TLSv1_1_method());
#line 1336 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#endif
#ifdef SSL_TXT_TLSV1_2
#define XSubPPtmpAAAC 1


XS(XS_Net__SSLeay_CTX_tlsv1_2_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_tlsv1_2_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SSL_CTX *	RETVAL;
	dXSTARG;
#line 1137 "SSLeay.xs"
     RETVAL = SSL_CTX_new (TLSv1_2_method());
#line 1362 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_CTX_new_with_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_new_with_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "meth");
    {
	SSL_METHOD *	meth = INT2PTR(SSL_METHOD *,SvIV(ST(0)));
	SSL_CTX *	RETVAL;
	dXSTARG;
#line 1147 "SSLeay.xs"
     RETVAL = SSL_CTX_new (meth);
#line 1386 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
#line 1155 "SSLeay.xs"
        cb_data_advanced_drop(ctx); /* clean callback related data from global hash */
        SSL_CTX_free(ctx);
#line 1408 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_CTX_add_session); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_add_session)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, ses");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	SSL_SESSION *	ses = INT2PTR(SSL_SESSION *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_add_session(ctx, ses);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_remove_session); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_remove_session)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, ses");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	SSL_SESSION *	ses = INT2PTR(SSL_SESSION *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_remove_session(ctx, ses);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_flush_sessions); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_flush_sessions)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, tm");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	long	tm = (long)SvIV(ST(1));

	SSL_CTX_flush_sessions(ctx, tm);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_CTX_set_default_verify_paths); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_default_verify_paths)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_set_default_verify_paths(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_load_verify_locations); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_load_verify_locations)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ctx, CAfile, CApath");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	char *	CAfile = (char *)SvPV_nolen(ST(1));
	char *	CApath = (char *)SvPV_nolen(ST(2));
	int	RETVAL;
	dXSTARG;
#line 1183 "SSLeay.xs"
     RETVAL = SSL_CTX_load_verify_locations (ctx,
					     CAfile?(*CAfile?CAfile:NULL):NULL,
					     CApath?(*CApath?CApath:NULL):NULL
					     );
#line 1523 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_verify); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_verify)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "ctx, mode, callback=&PL_sv_undef");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	mode = (int)SvIV(ST(1));
	SV *	callback;

	if (items < 3)
	    callback = &PL_sv_undef;
	else {
	    callback = ST(2);
	}
#line 1197 "SSLeay.xs"
    /* Former versions of SSLeay checked if the callback was a true boolean value
     * and didn't call it if it was false. Therefor some people set the callback
     * to '0' if they don't want to use it (IO::Socket::SSL for example). Therefor
     * we don't execute the callback if it's value isn't something true to retain
     * backwards compatibility.
     */

    if (callback==NULL || !SvOK(callback) || !SvTRUE(callback)) {
        SSL_CTX_set_verify(ctx, mode, NULL);
        cb_data_advanced_put(ctx, "ssleay_verify_callback!!func", NULL);
    } else {
        cb_data_advanced_put(ctx, "ssleay_verify_callback!!func", newSVsv(callback));
        SSL_CTX_set_verify(ctx, mode, &ssleay_verify_callback_invoke);
    }
#line 1565 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_get_error); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_error)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, ret");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	ret = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_error(s, ret);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define REM10 "============= SSL functions =============="

XS(XS_Net__SSLeay_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	SSL *	RETVAL;
	dXSTARG;

	RETVAL = SSL_new(ctx);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
#line 1227 "SSLeay.xs"
        cb_data_advanced_drop(s); /* clean callback related data from global hash */
        SSL_free(s);
#line 1632 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}

#if 0 /* this seems to be gone in 0.9.0 */
#define XSubPPtmpAAAD 1


XS(XS_Net__SSLeay_debug); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_debug)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "file");
    {
	char *	file = (char *)SvPV_nolen(ST(0));

	SSL_debug(file);
    }
    XSRETURN_EMPTY;
}

#endif

XS(XS_Net__SSLeay_accept); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_accept)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_accept(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_clear); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_clear)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));

	SSL_clear(s);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_connect); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_connect)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_connect(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if defined(WIN32)
#define XSubPPtmpAAAE 1


XS(XS_Net__SSLeay_set_fd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_fd)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, fd");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	perl_filehandle_t	fd;
	int	RETVAL;
	dXSTARG;

	if (ST(1) && SvOK(ST(1)) && SvROK(ST(1))) {
		fd = (perl_filehandle_t)PerlIO_fileno( IoIFP( sv_2io(SvRV(ST(1))) ) );
	} else {
		fd = (perl_filehandle_t)SvIV(ST(1));
	};
#line 1257 "SSLeay.xs"
     RETVAL = SSL_set_fd(s,_get_osfhandle(fd));
#line 1750 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_rfd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_rfd)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, fd");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	perl_filehandle_t	fd;
	int	RETVAL;
	dXSTARG;

	if (ST(1) && SvOK(ST(1)) && SvROK(ST(1))) {
		fd = (perl_filehandle_t)PerlIO_fileno( IoIFP( sv_2io(SvRV(ST(1))) ) );
	} else {
		fd = (perl_filehandle_t)SvIV(ST(1));
	};
#line 1266 "SSLeay.xs"
     RETVAL = SSL_set_rfd(s,_get_osfhandle(fd));
#line 1780 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_wfd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_wfd)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, fd");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	perl_filehandle_t	fd;
	int	RETVAL;
	dXSTARG;

	if (ST(1) && SvOK(ST(1)) && SvROK(ST(1))) {
		fd = (perl_filehandle_t)PerlIO_fileno( IoIFP( sv_2io(SvRV(ST(1))) ) );
	} else {
		fd = (perl_filehandle_t)SvIV(ST(1));
	};
#line 1275 "SSLeay.xs"
     RETVAL = SSL_set_wfd(s,_get_osfhandle(fd));
#line 1810 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAF 1


XS(XS_Net__SSLeay_set_fd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_fd)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, fd");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	perl_filehandle_t	fd;
	int	RETVAL;
	dXSTARG;

	if (ST(1) && SvOK(ST(1)) && SvROK(ST(1))) {
		fd = (perl_filehandle_t)PerlIO_fileno( IoIFP( sv_2io(SvRV(ST(1))) ) );
	} else {
		fd = (perl_filehandle_t)SvIV(ST(1));
	};

	RETVAL = SSL_set_fd(s, fd);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_rfd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_rfd)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, fd");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	perl_filehandle_t	fd;
	int	RETVAL;
	dXSTARG;

	if (ST(1) && SvOK(ST(1)) && SvROK(ST(1))) {
		fd = (perl_filehandle_t)PerlIO_fileno( IoIFP( sv_2io(SvRV(ST(1))) ) );
	} else {
		fd = (perl_filehandle_t)SvIV(ST(1));
	};

	RETVAL = SSL_set_rfd(s, fd);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_wfd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_wfd)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, fd");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	perl_filehandle_t	fd;
	int	RETVAL;
	dXSTARG;

	if (ST(1) && SvOK(ST(1)) && SvROK(ST(1))) {
		fd = (perl_filehandle_t)PerlIO_fileno( IoIFP( sv_2io(SvRV(ST(1))) ) );
	} else {
		fd = (perl_filehandle_t)SvIV(ST(1));
	};

	RETVAL = SSL_set_wfd(s, fd);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_get_fd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_fd)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_fd(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "s, max=32768");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	max;
#line 1307 "SSLeay.xs"
	char *buf;
	int got;
#line 1948 "SSLeay.c"
	AV *	RETVAL;

	if (items < 2)
	    max = 32768;
	else {
	    max = (int)SvIV(ST(1));
	}
#line 1310 "SSLeay.xs"
	New(0, buf, max, char);
	got = SSL_read(s, buf, max);

	/* If in list context, return 2-item list:
	 *   first return value:  data gotten, or undef on error (got<0)
	 *   second return value: result from SSL_read()
	 */
	if (GIMME_V==G_ARRAY) {
	    EXTEND(SP, 2);
	    PUSHs(sv_2mortal(got>=0 ? newSVpvn(buf, got) : newSV(0)));
	    PUSHs(sv_2mortal(newSViv(got)));

	/* If in scalar or void context, return data gotten, or undef on error. */
	} else {
	    EXTEND(SP, 1);
	    PUSHs(sv_2mortal(got>=0 ? newSVpvn(buf, got) : newSV(0)));
	}

	Safefree(buf);
#line 1976 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_peek); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_peek)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "s, max=32768");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	max;
#line 1335 "SSLeay.xs"
	char *buf;
	int got;
#line 1999 "SSLeay.c"

	if (items < 2)
	    max = 32768;
	else {
	    max = (int)SvIV(ST(1));
	}
#line 1338 "SSLeay.xs"
	New(0, buf, max, char);
	ST(0) = sv_newmortal();   /* Undefined to start with */
	if ((got = SSL_peek(s, buf, max)) >= 0)
		sv_setpvn( ST(0), buf, got);
	Safefree(buf);
#line 2012 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_write); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_write)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, buf");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
#line 1348 "SSLeay.xs"
     STRLEN len;
#line 2032 "SSLeay.c"
	char *	buf = SvPV( ST(1), len);
	int	RETVAL;
	dXSTARG;
#line 1352 "SSLeay.xs"
     RETVAL = SSL_write (s, buf, (int)len);
#line 2038 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_write_partial); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_write_partial)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "s, from, count, buf");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	from = (int)SvIV(ST(1));
	int	count = (int)SvIV(ST(2));
#line 1362 "SSLeay.xs"
     STRLEN ulen;
     IV len;
#line 2062 "SSLeay.c"
	char *	buf = SvPV( ST(3), ulen);
	int	RETVAL;
	dXSTARG;
#line 1367 "SSLeay.xs"
      /*
     if (SvROK( ST(3) )) {
       SV* t = SvRV( ST(3) );
       buf = SvPV( t, len);
     } else
       buf = SvPV( ST(3), len);
       */
     PR4("write_partial from=%d count=%d len=%ul\n",from,count,ulen);
     /*PR2("buf='%s'\n",&buf[from]); / * too noisy */
     len = (IV)ulen;
     len -= from;
     if (len < 0) {
       croak("from beyound end of buffer");
       RETVAL = -1;
     } else
       RETVAL = SSL_write (s, &(buf[from]), (count<=len)?count:len);
#line 2083 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_use_RSAPrivateKey); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_use_RSAPrivateKey)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, rsa");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	RSA *	rsa = INT2PTR(RSA *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_use_RSAPrivateKey(s, rsa);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_use_RSAPrivateKey_ASN1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_use_RSAPrivateKey_ASN1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "s, d, len");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	unsigned char *	d = (unsigned char *)SvPV_nolen(ST(1));
	long	len = (long)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_use_RSAPrivateKey_ASN1(s, d, len);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_use_RSAPrivateKey_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_use_RSAPrivateKey_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "s, file, type");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	char *	file = (char *)SvPV_nolen(ST(1));
	int	type = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_use_RSAPrivateKey_file(s, file, type);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_use_RSAPrivateKey_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_use_RSAPrivateKey_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ctx, file, type");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	char *	file = (char *)SvPV_nolen(ST(1));
	int	type = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_use_RSAPrivateKey_file(ctx, file, type);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_use_PrivateKey); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_use_PrivateKey)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, pkey");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	EVP_PKEY *	pkey = INT2PTR(EVP_PKEY *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_use_PrivateKey(s, pkey);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_use_PrivateKey_ASN1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_use_PrivateKey_ASN1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "pk, s, d, len");
    {
	int	pk = (int)SvIV(ST(0));
	SSL *	s = INT2PTR(SSL *,SvIV(ST(1)));
	unsigned char *	d = (unsigned char *)SvPV_nolen(ST(2));
	long	len = (long)SvIV(ST(3));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_use_PrivateKey_ASN1(pk, s, d, len);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_use_PrivateKey_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_use_PrivateKey_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "s, file, type");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	char *	file = (char *)SvPV_nolen(ST(1));
	int	type = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_use_PrivateKey_file(s, file, type);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_use_PrivateKey_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_use_PrivateKey_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ctx, file, type");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	char *	file = (char *)SvPV_nolen(ST(1));
	int	type = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_use_PrivateKey_file(ctx, file, type);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_use_certificate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_use_certificate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, x");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	X509 *	x = INT2PTR(X509 *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_use_certificate(s, x);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_use_certificate_ASN1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_use_certificate_ASN1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "s, d, len");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	unsigned char *	d = (unsigned char *)SvPV_nolen(ST(1));
	long	len = (long)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_use_certificate_ASN1(s, d, len);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_use_certificate_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_use_certificate_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "s, file, type");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	char *	file = (char *)SvPV_nolen(ST(1));
	int	type = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_use_certificate_file(s, file, type);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_use_certificate_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_use_certificate_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ctx, file, type");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	char *	file = (char *)SvPV_nolen(ST(1));
	int	type = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_use_certificate_file(ctx, file, type);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_state_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_state_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	const char *	RETVAL;
	dXSTARG;

	RETVAL = SSL_state_string(s);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_rstate_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_rstate_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	const char *	RETVAL;
	dXSTARG;

	RETVAL = SSL_rstate_string(s);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_state_string_long); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_state_string_long)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	const char *	RETVAL;
	dXSTARG;

	RETVAL = SSL_state_string_long(s);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_rstate_string_long); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_rstate_string_long)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	const char *	RETVAL;
	dXSTARG;

	RETVAL = SSL_rstate_string_long(s);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_time); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_time)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ses");
    {
	SSL_SESSION *	ses = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_time(ses);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_time); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_time)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ses, t");
    {
	SSL_SESSION *	ses = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	long	t = (long)SvIV(ST(1));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_set_time(ses, t);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_timeout); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_timeout)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ses");
    {
	SSL_SESSION *	ses = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_timeout(ses);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_timeout); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_timeout)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ses, t");
    {
	SSL_SESSION *	ses = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	long	t = (long)SvIV(ST(1));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_set_timeout(ses, t);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_copy_session_id); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_copy_session_id)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "to, from");
    {
	SSL *	to = INT2PTR(SSL *,SvIV(ST(0)));
	SSL *	from = INT2PTR(SSL *,SvIV(ST(1)));

	SSL_copy_session_id(to, from);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_set_read_ahead); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_read_ahead)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "s, yes=1");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	yes;

	if (items < 2)
	    yes = 1;
	else {
	    yes = (int)SvIV(ST(1));
	}

	SSL_set_read_ahead(s, yes);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_get_read_ahead); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_read_ahead)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_read_ahead(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_pending); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_pending)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_pending(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_cipher_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_cipher_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, str");
    {
	SSL_CTX *	s = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	char *	str = (char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_set_cipher_list(s, str);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_cipher_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_cipher_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, n");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	n = (int)SvIV(ST(1));
	const char *	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_cipher_list(s, n);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_cipher_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_cipher_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, str");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	char *	str = (char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_set_cipher_list(s, str);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_cipher); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_cipher)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	const char *	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_cipher(s);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_shared_ciphers); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_shared_ciphers)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "s, ignored_param1=0, ignored_param2=0");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	ignored_param1;
	int	ignored_param2;
#line 1534 "SSLeay.xs"
        char buf[8192];
#line 2751 "SSLeay.c"

	if (items < 2)
	    ignored_param1 = 0;
	else {
	    ignored_param1 = (int)SvIV(ST(1));
	}

	if (items < 3)
	    ignored_param2 = 0;
	else {
	    ignored_param2 = (int)SvIV(ST(2));
	}
#line 1536 "SSLeay.xs"
        ST(0) = sv_newmortal();   /* undef to start with */
        if(SSL_get_shared_ciphers(s, buf, sizeof(buf)))
            sv_setpvn(ST(0), buf, strlen(buf));
#line 2768 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_peer_certificate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_peer_certificate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	X509 *	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_peer_certificate(s);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_verify); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_verify)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "s, mode, callback");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	mode = (int)SvIV(ST(1));
	SV *	callback = ST(2);
#line 1550 "SSLeay.xs"
        if (callback==NULL || !SvOK(callback)) {
            SSL_set_verify(s, mode, NULL);
            cb_data_advanced_put(s, "ssleay_verify_callback!!func", NULL);
        }
        else {
            cb_data_advanced_put(s, "ssleay_verify_callback!!func", newSVsv(callback));
            SSL_set_verify(s, mode, &ssleay_verify_callback_invoke);
        }
#line 2819 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_set_bio); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_bio)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "s, rbio, wbio");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	BIO *	rbio = INT2PTR(BIO *,SvIV(ST(1)));
	BIO *	wbio = INT2PTR(BIO *,SvIV(ST(2)));

	SSL_set_bio(s, rbio, wbio);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_get_rbio); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_rbio)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	BIO *	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_rbio(s);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_wbio); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_wbio)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	BIO *	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_wbio(s);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SESSION_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SSL_SESSION *	RETVAL;
	dXSTARG;

	RETVAL = SSL_SESSION_new();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SESSION_print); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_print)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "fp, ses");
    {
	BIO *	fp = INT2PTR(BIO *,SvIV(ST(0)));
	SSL_SESSION *	ses = INT2PTR(SSL_SESSION *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_SESSION_print(fp, ses);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SESSION_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ses");
    {
	SSL_SESSION *	ses = INT2PTR(SSL_SESSION *,SvIV(ST(0)));

	SSL_SESSION_free(ses);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_i2d_SSL_SESSION); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_i2d_SSL_SESSION)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "in, pp");
    {
	SSL_SESSION *	in = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	unsigned char *	pp = (unsigned char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = i2d_SSL_SESSION(in, &pp);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_session); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_session)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "to, ses");
    {
	SSL *	to = INT2PTR(SSL *,SvIV(ST(0)));
	SSL_SESSION *	ses = INT2PTR(SSL_SESSION *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_set_session(to, ses);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER < 0x0090707fL
#define REM3 "NOTE: before 0.9.7g"
#define XSubPPtmpAAAG 1


XS(XS_Net__SSLeay_d2i_SSL_SESSION); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_d2i_SSL_SESSION)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "a, pp, length");
    {
	SSL_SESSION *	a = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	unsigned char *	pp = (unsigned char *)SvPV_nolen(ST(1));
	long	length = (long)SvIV(ST(2));
	SSL_SESSION *	RETVAL;
	dXSTARG;

	RETVAL = d2i_SSL_SESSION(&a, &pp, length);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAH 1


XS(XS_Net__SSLeay_d2i_SSL_SESSION); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_d2i_SSL_SESSION)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "a, pp, length");
    {
	SSL_SESSION *	a = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	const unsigned char *	pp = (const unsigned char *)SvPV_nolen(ST(1));
	long	length = (long)SvIV(ST(2));
	SSL_SESSION *	RETVAL;
	dXSTARG;

	RETVAL = d2i_SSL_SESSION(&a, &pp, length);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#endif
#define REM30 "SSLeay-0.9.0 defines these as macros. I expand them here for safety's sake"

XS(XS_Net__SSLeay_get_session); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_session)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	SSL_SESSION *	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_session(s);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get1_session); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get1_session)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	SSL_SESSION *	RETVAL;
	dXSTARG;

	RETVAL = SSL_get1_session(s);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_certificate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_certificate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	X509 *	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_certificate(s);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x0090806fL
#define REM18 "NOTE: requires 0.9.8f+"
#define XSubPPtmpAAAI 1


XS(XS_Net__SSLeay_get_SSL_CTX); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_SSL_CTX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	SSL_CTX *	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_SSL_CTX(s);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_SSL_CTX); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_SSL_CTX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, ctx");
    {
	SSL_CTX *	RETVAL;
	dXSTARG;
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	SSL_CTX*	ctx = INT2PTR(SSL_CTX *,SvIV(ST(1)));

	RETVAL = SSL_set_SSL_CTX(ssl, ctx);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_ctrl); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ctrl)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "ssl, cmd, larg, parg");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	int	cmd = (int)SvIV(ST(1));
	long	larg = (long)SvIV(ST(2));
	char *	parg = (char *)SvPV_nolen(ST(3));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_ctrl(ssl, cmd, larg, parg);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_CTX_ctrl); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_ctrl)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "ctx, cmd, larg, parg");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	cmd = (int)SvIV(ST(1));
	long	larg = (long)SvIV(ST(2));
	char *	parg = (char *)SvPV_nolen(ST(3));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_ctrl(ctx, cmd, larg, parg);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_options); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_options)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_options(ssl);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_options); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_options)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, op");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	long	op = (long)SvIV(ST(1));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_set_options(ssl, op);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_get_options); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_get_options)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_get_options(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_options); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_options)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, op");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	long	op = (long)SvIV(ST(1));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_set_options(ctx, op);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x10000000L
#define XSubPPtmpAAAJ 1


XS(XS_Net__SSLeay_CTX_sessions); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sessions)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	struct lhash_st_SSL_SESSION *	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sessions(ctx);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAK 1


XS(XS_Net__SSLeay_CTX_sessions); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sessions)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	LHASH *	RETVAL;
	dXSTARG;
#line 1686 "SSLeay.xs"
    /* NOTE: This should be deprecated. Corresponding macro was removed from ssl.h as of 0.9.2 */
     if (ctx == NULL) croak("NULL SSL context passed as argument.");
     RETVAL = ctx -> sessions;
#line 3359 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_CTX_sess_number); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sess_number)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	unsigned long	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sess_number(ctx);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_sess_connect); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sess_connect)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sess_connect(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_sess_connect_good); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sess_connect_good)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sess_connect_good(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_sess_connect_renegotiate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sess_connect_renegotiate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sess_connect_renegotiate(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_sess_accept); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sess_accept)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sess_accept(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_sess_accept_renegotiate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sess_accept_renegotiate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sess_accept_renegotiate(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_sess_accept_good); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sess_accept_good)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sess_accept_good(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_sess_hits); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sess_hits)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sess_hits(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_sess_cb_hits); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sess_cb_hits)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sess_cb_hits(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_sess_misses); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sess_misses)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sess_misses(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_sess_timeouts); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sess_timeouts)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sess_timeouts(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_sess_cache_full); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sess_cache_full)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sess_cache_full(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_sess_get_cache_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sess_get_cache_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sess_get_cache_size(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_sess_set_cache_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_sess_set_cache_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, size");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	size = (int)SvIV(ST(1));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_sess_set_cache_size(ctx, size);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_want); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_want)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_want(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_state); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_state)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_state(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)
#define XSubPPtmpAAAL 1


XS(XS_Net__SSLeay_set_tlsext_host_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_tlsext_host_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, name");
    {
	long	RETVAL;
	dXSTARG;
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	const char *	name = (const char *)SvPV_nolen(ST(1));

	RETVAL = SSL_set_tlsext_host_name(ssl, name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_servername); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_servername)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "s, type=TLSEXT_NAMETYPE_host_name");
    {
	const char *	RETVAL;
	dXSTARG;
	const SSL *	s = INT2PTR(const SSL *,SvIV(ST(0)));
	int	type;

	if (items < 2)
	    type = TLSEXT_NAMETYPE_host_name;
	else {
	    type = (int)SvIV(ST(1));
	}

	RETVAL = SSL_get_servername(s, type);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_servername_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_servername_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	int	RETVAL;
	dXSTARG;
	const SSL *	s = INT2PTR(const SSL *,SvIV(ST(0)));

	RETVAL = SSL_get_servername_type(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_tlsext_servername_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_tlsext_servername_callback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "ctx, callback=&PL_sv_undef, data=&PL_sv_undef");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	SV *	callback;
	SV *	data;

	if (items < 2)
	    callback = &PL_sv_undef;
	else {
	    callback = ST(1);
	}

	if (items < 3)
	    data = &PL_sv_undef;
	else {
	    data = ST(2);
	}
#line 1776 "SSLeay.xs"
    if (callback==NULL || !SvOK(callback)) {
        SSL_CTX_set_tlsext_servername_callback(ctx, NULL);
        SSL_CTX_set_tlsext_servername_arg(ctx, NULL);
        cb_data_advanced_put(ctx, "tlsext_servername_callback!!data", NULL);
        cb_data_advanced_put(ctx, "tlsext_servername_callback!!func", NULL);
    } else {
        cb_data_advanced_put(ctx, "tlsext_servername_callback!!data", newSVsv(data));
        cb_data_advanced_put(ctx, "tlsext_servername_callback!!func", newSVsv(callback));
        SSL_CTX_set_tlsext_servername_callback(ctx, &tlsext_servername_callback_invoke);
        SSL_CTX_set_tlsext_servername_arg(ctx, (void*)ctx);
    }
#line 3835 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}

#endif

XS(XS_Net__SSLeay_BIO_f_ssl); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_f_ssl)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	BIO_METHOD *	RETVAL;
	dXSTARG;

	RETVAL = BIO_f_ssl();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_BIO_s_mem); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_s_mem)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	BIO_METHOD *	RETVAL;
	dXSTARG;

	RETVAL = BIO_s_mem();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_ERR_get_error); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ERR_get_error)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	unsigned long	RETVAL;
	dXSTARG;

	RETVAL = ERR_get_error();
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_ERR_peek_error); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ERR_peek_error)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	unsigned long	RETVAL;
	dXSTARG;

	RETVAL = ERR_peek_error();
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_ERR_put_error); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ERR_put_error)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "lib, func, reason, file, line");
    {
	int	lib = (int)SvIV(ST(0));
	int	func = (int)SvIV(ST(1));
	int	reason = (int)SvIV(ST(2));
	char *	file = (char *)SvPV_nolen(ST(3));
	int	line = (int)SvIV(ST(4));

	ERR_put_error(lib, func, reason, file, line);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_ERR_clear_error); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ERR_clear_error)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	ERR_clear_error();
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_ERR_error_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ERR_error_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "error, buf=NULL");
    {
	unsigned long	error = (unsigned long)SvUV(ST(0));
	char *	buf;
	char *	RETVAL;
	dXSTARG;

	if (items < 2)
	    buf = NULL;
	else {
	    buf = (char *)SvPV_nolen(ST(1));
	}
#line 1818 "SSLeay.xs"
     RETVAL = ERR_error_string(error,buf);
#line 3990 "SSLeay.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_load_error_strings); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_load_error_strings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	SSL_load_error_strings();
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_ERR_load_crypto_strings); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ERR_load_crypto_strings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	ERR_load_crypto_strings();
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_FIPS_mode_set); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_FIPS_mode_set)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "onoff");
    {
	int	RETVAL;
	dXSTARG;
	int	onoff = (int)SvIV(ST(0));
#line 1831 "SSLeay.xs"
#ifdef USE_ITHREADS
               MUTEX_LOCK(&LIB_init_mutex);
#endif
#ifdef OPENSSL_FIPS
               RETVAL = FIPS_mode_set(onoff);
               if (!RETVAL) 
	       {
		   ERR_load_crypto_strings();
		   ERR_print_errors_fp(stderr);
               }
#else
               RETVAL = 1;
               fprintf(stderr, "SSL_FIPS_mode_set not available: OpenSSL not compiled with FIPS support\n");
#endif
#ifdef USE_ITHREADS
               MUTEX_UNLOCK(&LIB_init_mutex);
#endif
#line 4065 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_library_init); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_library_init)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 1859 "SSLeay.xs"
#ifdef USE_ITHREADS
		MUTEX_LOCK(&LIB_init_mutex);
#endif
		RETVAL = 0;
		if (!LIB_initialized) {
			RETVAL = SSL_library_init();
			LIB_initialized = 1;
		}
#ifdef USE_ITHREADS
		MUTEX_UNLOCK(&LIB_init_mutex);
#endif
#line 4098 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x0090700fL
#define REM5 "NOTE: requires 0.9.7+"
#define XSubPPtmpAAAM 1


XS(XS_Net__SSLeay_ENGINE_load_builtin_engines); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ENGINE_load_builtin_engines)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	ENGINE_load_builtin_engines();
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_ENGINE_register_all_complete); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ENGINE_register_all_complete)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	ENGINE_register_all_complete();
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_ENGINE_by_id); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ENGINE_by_id)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "id");
    {
	char *	id = (char *)SvPV_nolen(ST(0));
	ENGINE *	RETVAL;
	dXSTARG;

	RETVAL = ENGINE_by_id(id);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_ENGINE_set_default); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ENGINE_set_default)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "e, flags");
    {
	ENGINE *	e = INT2PTR(ENGINE *,SvIV(ST(0)));
	int	flags = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = ENGINE_set_default(e, flags);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_ERR_load_SSL_strings); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ERR_load_SSL_strings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	ERR_load_SSL_strings();
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_ERR_load_RAND_strings); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ERR_load_RAND_strings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	ERR_load_RAND_strings();
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_RAND_bytes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RAND_bytes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "buf, num");
    {
	SV *	buf = ST(0);
	int	num = (int)SvIV(ST(1));
#line 1904 "SSLeay.xs"
        int rc;
        unsigned char *random;
#line 4243 "SSLeay.c"
	int	RETVAL;
	dXSTARG;
#line 1907 "SSLeay.xs"
        New(0, random, num, unsigned char);
        rc = RAND_bytes(random, num);
        sv_setpvn(buf, (const char*)random, num);
        Safefree(random);
        RETVAL = rc;
#line 4252 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_RAND_pseudo_bytes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RAND_pseudo_bytes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "buf, num");
    {
	SV *	buf = ST(0);
	int	num = (int)SvIV(ST(1));
#line 1920 "SSLeay.xs"
        int rc;
        unsigned char *random;
#line 4275 "SSLeay.c"
	int	RETVAL;
	dXSTARG;
#line 1923 "SSLeay.xs"
        New(0, random, num, unsigned char);
        rc = RAND_pseudo_bytes(random, num);
        sv_setpvn(buf, (const char*)random, num);
        Safefree(random);
        RETVAL = rc;
#line 4284 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_RAND_add); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RAND_add)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "buf, num, entropy");
    {
	SV *	buf = ST(0);
	int	num = (int)SvIV(ST(1));
	double	entropy = (double)SvNV(ST(2));
#line 1937 "SSLeay.xs"
        STRLEN len;
#line 4307 "SSLeay.c"
#line 1939 "SSLeay.xs"
        RAND_add((const void *)SvPV(buf, len), num, entropy);
#line 4310 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_RAND_poll); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RAND_poll)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = RAND_poll();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_RAND_status); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RAND_status)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = RAND_status();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_RAND_egd_bytes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RAND_egd_bytes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "path, bytes");
    {
	const char *	path = (const char *)SvPV_nolen(ST(0));
	int	bytes = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = RAND_egd_bytes(path, bytes);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_RAND_file_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RAND_file_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "num");
    {
	size_t	num = (size_t)SvUV(ST(0));
#line 1956 "SSLeay.xs"
        char *buf;
#line 4395 "SSLeay.c"
	SV *	RETVAL;
#line 1958 "SSLeay.xs"
        New(0, buf, num, char);
        if (!RAND_file_name(buf, num)) {
            Safefree(buf);
            XSRETURN_UNDEF;
        }
        RETVAL = newSVpv(buf, 0);
        Safefree(buf);
#line 4405 "SSLeay.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_RAND_seed); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RAND_seed)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "buf");
    {
#line 1971 "SSLeay.xs"
     STRLEN len;
#line 4426 "SSLeay.c"
	char *	buf = SvPV( ST(1), len);
#line 1975 "SSLeay.xs"
     RAND_seed (buf, (int)len);
#line 4430 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_RAND_cleanup); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RAND_cleanup)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	RAND_cleanup();
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_RAND_load_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RAND_load_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "file_name, how_much");
    {
	char *	file_name = (char *)SvPV_nolen(ST(0));
	int	how_much = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = RAND_load_file(file_name, how_much);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_RAND_write_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RAND_write_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "file_name");
    {
	char *	file_name = (char *)SvPV_nolen(ST(0));
	int	RETVAL;
	dXSTARG;

	RETVAL = RAND_write_file(file_name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_RAND_egd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RAND_egd)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "path");
    {
	char *	path = (char *)SvPV_nolen(ST(0));
	int	RETVAL;
	dXSTARG;

	RETVAL = RAND_egd(path);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define REM40 "Minimal X509 stuff..., this is a bit ugly and should be put in its own modules Net::SSLeay::X509.pm"

XS(XS_Net__SSLeay_X509_get_issuer_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_get_issuer_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    {
	X509 *	cert = INT2PTR(X509 *,SvIV(ST(0)));
	X509_NAME *	RETVAL;
	dXSTARG;

	RETVAL = X509_get_issuer_name(cert);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_get_subject_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_get_subject_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    {
	X509 *	cert = INT2PTR(X509 *,SvIV(ST(0)));
	X509_NAME *	RETVAL;
	dXSTARG;

	RETVAL = X509_get_subject_name(cert);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_set_issuer_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_set_issuer_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, name");
    {
	int	RETVAL;
	dXSTARG;
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));
	X509_NAME *	name = INT2PTR(X509_NAME *,SvIV(ST(1)));

	RETVAL = X509_set_issuer_name(x, name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_set_subject_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_set_subject_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, name");
    {
	int	RETVAL;
	dXSTARG;
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));
	X509_NAME *	name = INT2PTR(X509_NAME *,SvIV(ST(1)));

	RETVAL = X509_set_subject_name(x, name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_set_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_set_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, version");
    {
	int	RETVAL;
	dXSTARG;
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));
	long	version = (long)SvIV(ST(1));

	RETVAL = X509_set_version(x, version);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_set_pubkey); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_set_pubkey)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, pkey");
    {
	int	RETVAL;
	dXSTARG;
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));
	EVP_PKEY *	pkey = INT2PTR(EVP_PKEY *,SvIV(ST(1)));

	RETVAL = X509_set_pubkey(x, pkey);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_get_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_get_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	long	RETVAL;
	dXSTARG;
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));

	RETVAL = X509_get_version(x);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_get_pubkey); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_get_pubkey)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	EVP_PKEY *	RETVAL;
	dXSTARG;
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));

	RETVAL = X509_get_pubkey(x);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_get_serialNumber); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_get_serialNumber)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	ASN1_INTEGER *	RETVAL;
	dXSTARG;
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));

	RETVAL = X509_get_serialNumber(x);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_set_serialNumber); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_set_serialNumber)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, serial");
    {
	int	RETVAL;
	dXSTARG;
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));
	ASN1_INTEGER *	serial = INT2PTR(ASN1_INTEGER *,SvIV(ST(1)));

	RETVAL = X509_set_serialNumber(x, serial);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_certificate_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_certificate_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "x, pubkey=NULL");
    {
	int	RETVAL;
	dXSTARG;
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));
	EVP_PKEY *	pubkey;

	if (items < 2)
	    pubkey = NULL;
	else {
	    pubkey = INT2PTR(EVP_PKEY *,SvIV(ST(1)));
	}

	RETVAL = X509_certificate_type(x, pubkey);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_sign); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_sign)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "x, pkey, md");
    {
	int	RETVAL;
	dXSTARG;
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));
	EVP_PKEY *	pkey = INT2PTR(EVP_PKEY *,SvIV(ST(1)));
	const EVP_MD *	md = INT2PTR(const EVP_MD *,SvIV(ST(2)));

	RETVAL = X509_sign(x, pkey, md);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_verify); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_verify)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, r");
    {
	int	RETVAL;
	dXSTARG;
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));
	EVP_PKEY *	r = INT2PTR(EVP_PKEY *,SvIV(ST(1)));

	RETVAL = X509_verify(x, r);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_NAME_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_NAME_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	X509_NAME *	RETVAL;
	dXSTARG;

	RETVAL = X509_NAME_new();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_NAME_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_NAME_hash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	unsigned long	RETVAL;
	dXSTARG;
	X509_NAME *	name = INT2PTR(X509_NAME *,SvIV(ST(0)));

	RETVAL = X509_NAME_hash(name);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_NAME_oneline); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_NAME_oneline)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	X509_NAME *	name = INT2PTR(X509_NAME *,SvIV(ST(0)));
#line 2046 "SSLeay.xs"
	char * buf;
#line 4880 "SSLeay.c"
#line 2048 "SSLeay.xs"
	ST(0) = sv_newmortal();   /* Undefined to start with */
	if ((buf = X509_NAME_oneline(name, NULL, 0))) {
		sv_setpvn( ST(0), buf, strlen(buf));
		OPENSSL_free(buf); /* mem was allocated by openssl */
	}
#line 4887 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_NAME_print_ex); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_NAME_print_ex)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "name, flags=XN_FLAG_RFC2253, utf8_decode=0");
    {
	X509_NAME *	name = INT2PTR(X509_NAME *,SvIV(ST(0)));
	unsigned long	flags;
	int	utf8_decode;
#line 2060 "SSLeay.xs"
        char * buf;
        BIO * bp;
        int n, i, ident=0;
#line 4911 "SSLeay.c"

	if (items < 2)
	    flags = XN_FLAG_RFC2253;
	else {
	    flags = (unsigned long)SvUV(ST(1));
	}

	if (items < 3)
	    utf8_decode = 0;
	else {
	    utf8_decode = (int)SvIV(ST(2));
	}
#line 2064 "SSLeay.xs"
        ST(0) = sv_newmortal(); /* undef to start with */
        bp = BIO_new(BIO_s_mem());
        if (bp) {
            if (X509_NAME_print_ex(bp, name, ident, flags)) {
                n = BIO_ctrl_pending(bp);
                New(0, buf, n, char);
                if (buf) {
                    i = BIO_read(bp,buf,n);
                    if (i>=0 && i<=n) {
                        sv_setpvn(ST(0), buf, i);
                        if (utf8_decode) sv_utf8_decode(ST(0));
                    }
                    Safefree(buf);
                }
            }
            BIO_free(bp);
        }
#line 4942 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_NAME_get_text_by_NID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_NAME_get_text_by_NID)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "name, nid");
    {
	X509_NAME *	name = INT2PTR(X509_NAME *,SvIV(ST(0)));
	int	nid = (int)SvIV(ST(1));
#line 2087 "SSLeay.xs"
	char* buf;
	int length;
#line 4964 "SSLeay.c"
#line 2090 "SSLeay.xs"
	ST(0) = sv_newmortal();   /* Undefined to start with */
	length = X509_NAME_get_text_by_NID(name, nid, NULL, 0);

       if (length>=0) {
               New(0, buf, length+1, char);
               if (X509_NAME_get_text_by_NID(name, nid, buf, length + 1)>=0)
                       sv_setpvn( ST(0), buf, length);
               Safefree(buf);
       }
#line 4975 "SSLeay.c"
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x0090500fL
#define REM17 "requires 0.9.5+"
#define XSubPPtmpAAAN 1


XS(XS_Net__SSLeay_X509_NAME_add_entry_by_NID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_NAME_add_entry_by_NID)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4 || items > 6)
       croak_xs_usage(cv,  "name, nid, type, bytes, loc=-1, set=0");
    {
	X509_NAME *	name = INT2PTR(X509_NAME *,SvIV(ST(0)));
	int	nid = (int)SvIV(ST(1));
	int	type = (int)SvIV(ST(2));
	int	loc;
	int	set;
#line 2111 "SSLeay.xs"
        STRLEN len;
#line 5003 "SSLeay.c"
	unsigned char *	bytes = (unsigned char *)SvPV(ST(3), len);
	int	RETVAL;
	dXSTARG;

	if (items < 5)
	    loc = -1;
	else {
	    loc = (int)SvIV(ST(4));
	}

	if (items < 6)
	    set = 0;
	else {
	    set = (int)SvIV(ST(5));
	}
#line 2115 "SSLeay.xs"
        RETVAL = X509_NAME_add_entry_by_NID(name,nid,type,bytes,len,loc,set);
#line 5021 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_NAME_add_entry_by_OBJ); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_NAME_add_entry_by_OBJ)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4 || items > 6)
       croak_xs_usage(cv,  "name, obj, type, bytes, loc=-1, set=0");
    {
	X509_NAME *	name = INT2PTR(X509_NAME *,SvIV(ST(0)));
	ASN1_OBJECT *	obj = INT2PTR(ASN1_OBJECT *,SvIV(ST(1)));
	int	type = (int)SvIV(ST(2));
	int	loc;
	int	set;
#line 2127 "SSLeay.xs"
        STRLEN len;
#line 5046 "SSLeay.c"
	unsigned char *	bytes = (unsigned char *)SvPV(ST(3), len);
	int	RETVAL;
	dXSTARG;

	if (items < 5)
	    loc = -1;
	else {
	    loc = (int)SvIV(ST(4));
	}

	if (items < 6)
	    set = 0;
	else {
	    set = (int)SvIV(ST(5));
	}
#line 2131 "SSLeay.xs"
        RETVAL = X509_NAME_add_entry_by_OBJ(name,obj,type,bytes,len,loc,set);
#line 5064 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_NAME_add_entry_by_txt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_NAME_add_entry_by_txt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4 || items > 6)
       croak_xs_usage(cv,  "name, field, type, bytes, loc=-1, set=0");
    {
	X509_NAME *	name = INT2PTR(X509_NAME *,SvIV(ST(0)));
	char *	field = (char *)SvPV_nolen(ST(1));
	int	type = (int)SvIV(ST(2));
	int	loc;
	int	set;
#line 2143 "SSLeay.xs"
        STRLEN len;
#line 5089 "SSLeay.c"
	unsigned char *	bytes = (unsigned char *)SvPV(ST(3), len);
	int	RETVAL;
	dXSTARG;

	if (items < 5)
	    loc = -1;
	else {
	    loc = (int)SvIV(ST(4));
	}

	if (items < 6)
	    set = 0;
	else {
	    set = (int)SvIV(ST(5));
	}
#line 2147 "SSLeay.xs"
        RETVAL = X509_NAME_add_entry_by_txt(name,field,type,bytes,len,loc,set);
#line 5107 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_X509_NAME_cmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_NAME_cmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "a, b");
    {
	int	RETVAL;
	dXSTARG;
	const X509_NAME *	a = INT2PTR(const X509_NAME *,SvIV(ST(0)));
	const X509_NAME *	b = INT2PTR(const X509_NAME *,SvIV(ST(1)));

	RETVAL = X509_NAME_cmp(a, b);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_NAME_entry_count); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_NAME_entry_count)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	int	RETVAL;
	dXSTARG;
	X509_NAME *	name = INT2PTR(X509_NAME *,SvIV(ST(0)));

	RETVAL = X509_NAME_entry_count(name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_NAME_get_entry); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_NAME_get_entry)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "name, loc");
    {
	X509_NAME_ENTRY *	RETVAL;
	dXSTARG;
	X509_NAME *	name = INT2PTR(X509_NAME *,SvIV(ST(0)));
	int	loc = (int)SvIV(ST(1));

	RETVAL = X509_NAME_get_entry(name, loc);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_NAME_ENTRY_get_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_NAME_ENTRY_get_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ne");
    {
	ASN1_STRING *	RETVAL;
	dXSTARG;
	X509_NAME_ENTRY *	ne = INT2PTR(X509_NAME_ENTRY *,SvIV(ST(0)));

	RETVAL = X509_NAME_ENTRY_get_data(ne);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_NAME_ENTRY_get_object); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_NAME_ENTRY_get_object)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ne");
    {
	ASN1_OBJECT *	RETVAL;
	dXSTARG;
	X509_NAME_ENTRY *	ne = INT2PTR(X509_NAME_ENTRY *,SvIV(ST(0)));

	RETVAL = X509_NAME_ENTRY_get_object(ne);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_CRL_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	X509_CRL *	x = INT2PTR(X509_CRL *,SvIV(ST(0)));

	X509_CRL_free(x);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_X509_CRL_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	X509_CRL *	RETVAL;
	dXSTARG;

	RETVAL = X509_CRL_new();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x0090700fL
#define REM19 "requires 0.9.7+"
#define XSubPPtmpAAAO 1


XS(XS_Net__SSLeay_X509_CRL_set_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_set_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, version");
    {
	int	RETVAL;
	dXSTARG;
	X509_CRL *	x = INT2PTR(X509_CRL *,SvIV(ST(0)));
	long	version = (long)SvIV(ST(1));

	RETVAL = X509_CRL_set_version(x, version);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_CRL_set_issuer_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_set_issuer_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, name");
    {
	int	RETVAL;
	dXSTARG;
	X509_CRL *	x = INT2PTR(X509_CRL *,SvIV(ST(0)));
	X509_NAME *	name = INT2PTR(X509_NAME *,SvIV(ST(1)));

	RETVAL = X509_CRL_set_issuer_name(x, name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_CRL_set_lastUpdate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_set_lastUpdate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, tm");
    {
	int	RETVAL;
	dXSTARG;
	X509_CRL *	x = INT2PTR(X509_CRL *,SvIV(ST(0)));
	ASN1_TIME *	tm = INT2PTR(ASN1_TIME *,SvIV(ST(1)));

	RETVAL = X509_CRL_set_lastUpdate(x, tm);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_CRL_set_nextUpdate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_set_nextUpdate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, tm");
    {
	int	RETVAL;
	dXSTARG;
	X509_CRL *	x = INT2PTR(X509_CRL *,SvIV(ST(0)));
	ASN1_TIME *	tm = INT2PTR(ASN1_TIME *,SvIV(ST(1)));

	RETVAL = X509_CRL_set_nextUpdate(x, tm);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_CRL_sort); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_sort)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	int	RETVAL;
	dXSTARG;
	X509_CRL *	x = INT2PTR(X509_CRL *,SvIV(ST(0)));

	RETVAL = X509_CRL_sort(x);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_X509_CRL_get_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_get_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	long	RETVAL;
	dXSTARG;
	X509_CRL *	x = INT2PTR(X509_CRL *,SvIV(ST(0)));

	RETVAL = X509_CRL_get_version(x);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_CRL_get_issuer); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_get_issuer)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	X509_NAME *	RETVAL;
	dXSTARG;
	X509_CRL *	x = INT2PTR(X509_CRL *,SvIV(ST(0)));

	RETVAL = X509_CRL_get_issuer(x);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_CRL_get_lastUpdate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_get_lastUpdate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	ASN1_TIME *	RETVAL;
	dXSTARG;
	X509_CRL *	x = INT2PTR(X509_CRL *,SvIV(ST(0)));

	RETVAL = X509_CRL_get_lastUpdate(x);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_CRL_get_nextUpdate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_get_nextUpdate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	ASN1_TIME *	RETVAL;
	dXSTARG;
	X509_CRL *	x = INT2PTR(X509_CRL *,SvIV(ST(0)));

	RETVAL = X509_CRL_get_nextUpdate(x);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_CRL_verify); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_verify)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "a, r");
    {
	int	RETVAL;
	dXSTARG;
	X509_CRL *	a = INT2PTR(X509_CRL *,SvIV(ST(0)));
	EVP_PKEY *	r = INT2PTR(EVP_PKEY *,SvIV(ST(1)));

	RETVAL = X509_CRL_verify(a, r);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_CRL_sign); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_sign)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "x, pkey, md");
    {
	int	RETVAL;
	dXSTARG;
	X509_CRL *	x = INT2PTR(X509_CRL *,SvIV(ST(0)));
	EVP_PKEY *	pkey = INT2PTR(EVP_PKEY *,SvIV(ST(1)));
	const EVP_MD *	md = INT2PTR(const EVP_MD *,SvIV(ST(2)));

	RETVAL = X509_CRL_sign(x, pkey, md);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x0090700fL
#define REM20 "requires 0.9.7+"
#define XSubPPtmpAAAP 1


XS(XS_Net__SSLeay_P_X509_CRL_set_serial); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_X509_CRL_set_serial)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "crl, crl_number");
    {
	X509_CRL *	crl = INT2PTR(X509_CRL *,SvIV(ST(0)));
	ASN1_INTEGER *	crl_number = INT2PTR(ASN1_INTEGER *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;
#line 2220 "SSLeay.xs"
        RETVAL = 0;
        if (crl && crl_number)
            if (X509_CRL_add1_ext_i2d(crl, NID_crl_number, crl_number, 0, 0)) RETVAL = 1;
#line 5544 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_P_X509_CRL_get_serial); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_X509_CRL_get_serial)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "crl");
    {
	X509_CRL *	crl = INT2PTR(X509_CRL *,SvIV(ST(0)));
	ASN1_INTEGER *	RETVAL;
	dXSTARG;
#line 2230 "SSLeay.xs"
        int i;
#line 5567 "SSLeay.c"
#line 2232 "SSLeay.xs"
        RETVAL = (ASN1_INTEGER *)X509_CRL_get_ext_d2i(crl, NID_crl_number, &i, NULL);
        if (!RETVAL || i==-1) XSRETURN_UNDEF;
#line 5571 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_P_X509_CRL_add_revoked_serial_hex); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_X509_CRL_add_revoked_serial_hex)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3 || items > 5)
       croak_xs_usage(cv,  "crl, serial_hex, rev_time, reason_code=0, comp_time=NULL");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	X509_CRL *	crl = INT2PTR(X509_CRL *,SvIV(ST(0)));
	char *	serial_hex = (char *)SvPV_nolen(ST(1));
	ASN1_TIME *	rev_time = INT2PTR(ASN1_TIME *,SvIV(ST(2)));
	long	reason_code;
	ASN1_TIME *	comp_time;
#line 2245 "SSLeay.xs"
        BIGNUM *bn = NULL;
        ASN1_INTEGER *sn;
        X509_REVOKED *rev;
        ASN1_ENUMERATED *rsn = NULL;
        int rv;
#line 5602 "SSLeay.c"

	if (items < 4)
	    reason_code = 0;
	else {
	    reason_code = (long)SvIV(ST(3));
	}

	if (items < 5)
	    comp_time = NULL;
	else {
	    comp_time = INT2PTR(ASN1_TIME *,SvIV(ST(4)));
	}
#line 2251 "SSLeay.xs"
        rv=0;
        rev = X509_REVOKED_new();
        if (rev) {
            if (BN_hex2bn(&bn, serial_hex)) {
                sn = BN_to_ASN1_INTEGER(bn, NULL);
                if (sn) {
                    X509_REVOKED_set_serialNumber(rev, sn);
                    ASN1_INTEGER_free(sn);
                    rv = 1;
                }
                BN_free(bn);
            }
        }
        if (!rv) XSRETURN_IV(0);

        if (!rev_time) XSRETURN_IV(0);
        if (!X509_REVOKED_set_revocationDate(rev, rev_time)) XSRETURN_IV(0);

        if(reason_code) {
            rv = 0;
            rsn = ASN1_ENUMERATED_new();
            if (rsn) {
                if (ASN1_ENUMERATED_set(rsn, reason_code))
                    if (X509_REVOKED_add1_ext_i2d(rev, NID_crl_reason, rsn, 0, 0))
                        rv=1;
                ASN1_ENUMERATED_free(rsn);
            }
            if (!rv) XSRETURN_IV(0);
        }

        if(comp_time) {
            X509_REVOKED_add1_ext_i2d(rev, NID_invalidity_date, comp_time, 0, 0);
        }

        if(!X509_CRL_add0_revoked(crl, rev)) XSRETURN_IV(0);
        XSRETURN_IV(1);
#line 5652 "SSLeay.c"
	PUTBACK;
	return;
    }
}

#endif

XS(XS_Net__SSLeay_X509_REQ_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	X509_REQ *	RETVAL;
	dXSTARG;

	RETVAL = X509_REQ_new();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_REQ_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	X509_REQ *	x = INT2PTR(X509_REQ *,SvIV(ST(0)));

	X509_REQ_free(x);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_X509_REQ_get_subject_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_get_subject_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	X509_NAME *	RETVAL;
	dXSTARG;
	X509_REQ *	x = INT2PTR(X509_REQ *,SvIV(ST(0)));

	RETVAL = X509_REQ_get_subject_name(x);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_REQ_set_subject_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_set_subject_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, name");
    {
	int	RETVAL;
	dXSTARG;
	X509_REQ *	x = INT2PTR(X509_REQ *,SvIV(ST(0)));
	X509_NAME *	name = INT2PTR(X509_NAME *,SvIV(ST(1)));

	RETVAL = X509_REQ_set_subject_name(x, name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_REQ_set_pubkey); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_set_pubkey)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, pkey");
    {
	int	RETVAL;
	dXSTARG;
	X509_REQ *	x = INT2PTR(X509_REQ *,SvIV(ST(0)));
	EVP_PKEY *	pkey = INT2PTR(EVP_PKEY *,SvIV(ST(1)));

	RETVAL = X509_REQ_set_pubkey(x, pkey);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_REQ_get_pubkey); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_get_pubkey)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	EVP_PKEY *	RETVAL;
	dXSTARG;
	X509_REQ *	x = INT2PTR(X509_REQ *,SvIV(ST(0)));

	RETVAL = X509_REQ_get_pubkey(x);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_REQ_sign); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_sign)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "x, pk, md");
    {
	int	RETVAL;
	dXSTARG;
	X509_REQ *	x = INT2PTR(X509_REQ *,SvIV(ST(0)));
	EVP_PKEY *	pk = INT2PTR(EVP_PKEY *,SvIV(ST(1)));
	const EVP_MD *	md = INT2PTR(const EVP_MD *,SvIV(ST(2)));

	RETVAL = X509_REQ_sign(x, pk, md);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_REQ_verify); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_verify)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, r");
    {
	int	RETVAL;
	dXSTARG;
	X509_REQ *	x = INT2PTR(X509_REQ *,SvIV(ST(0)));
	EVP_PKEY *	r = INT2PTR(EVP_PKEY *,SvIV(ST(1)));

	RETVAL = X509_REQ_verify(x, r);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_REQ_set_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_set_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, version");
    {
	int	RETVAL;
	dXSTARG;
	X509_REQ *	x = INT2PTR(X509_REQ *,SvIV(ST(0)));
	long	version = (long)SvIV(ST(1));

	RETVAL = X509_REQ_set_version(x, version);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_REQ_get_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_get_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	long	RETVAL;
	dXSTARG;
	X509_REQ *	x = INT2PTR(X509_REQ *,SvIV(ST(0)));

	RETVAL = X509_REQ_get_version(x);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_REQ_get_attr_count); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_get_attr_count)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "req");
    {
	int	RETVAL;
	dXSTARG;
	const X509_REQ *	req = INT2PTR(const X509_REQ *,SvIV(ST(0)));

	RETVAL = X509_REQ_get_attr_count(req);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_REQ_get_attr_by_NID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_get_attr_by_NID)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "req, nid, lastpos=-1");
    {
	int	RETVAL;
	dXSTARG;
	const X509_REQ *	req = INT2PTR(const X509_REQ *,SvIV(ST(0)));
	int	nid = (int)SvIV(ST(1));
	int	lastpos;

	if (items < 3)
	    lastpos = -1;
	else {
	    lastpos = (int)SvIV(ST(2));
	}

	RETVAL = X509_REQ_get_attr_by_NID(req, nid, lastpos);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_REQ_get_attr_by_OBJ); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_get_attr_by_OBJ)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "req, obj, lastpos=-1");
    {
	int	RETVAL;
	dXSTARG;
	const X509_REQ *	req = INT2PTR(const X509_REQ *,SvIV(ST(0)));
	ASN1_OBJECT *	obj = INT2PTR(ASN1_OBJECT *,SvIV(ST(1)));
	int	lastpos;

	if (items < 3)
	    lastpos = -1;
	else {
	    lastpos = (int)SvIV(ST(2));
	}

	RETVAL = X509_REQ_get_attr_by_OBJ(req, obj, lastpos);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_REQ_add1_attr_by_NID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_add1_attr_by_NID)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "req, nid, type, bytes");
    {
	X509_REQ *	req = INT2PTR(X509_REQ *,SvIV(ST(0)));
	int	nid = (int)SvIV(ST(1));
	int	type = (int)SvIV(ST(2));
#line 2335 "SSLeay.xs"
        STRLEN len;
#line 5980 "SSLeay.c"
	unsigned char *	bytes = (unsigned char *)SvPV(ST(3), len);
	int	RETVAL;
	dXSTARG;
#line 2339 "SSLeay.xs"
        RETVAL = X509_REQ_add1_attr_by_NID(req,nid,type,bytes,len);
#line 5986 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x0090700fL
#define REM21 "requires 0.9.7+"
#define XSubPPtmpAAAQ 1


XS(XS_Net__SSLeay_P_X509_REQ_get_attr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_X509_REQ_get_attr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "req, n");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	X509_REQ *	req = INT2PTR(X509_REQ *,SvIV(ST(0)));
	int	n = (int)SvIV(ST(1));
#line 2351 "SSLeay.xs"
        X509_ATTRIBUTE * att;
        int count, i;
        ASN1_STRING * s;
#line 6016 "SSLeay.c"
#line 2355 "SSLeay.xs"
        att = X509_REQ_get_attr(req,n);
        if (att->single) {
            s = (att->value.single->value.asn1_string);
            XPUSHs(sv_2mortal(newSViv(PTR2IV(s))));
        }
        else {
            count = sk_ASN1_TYPE_num(att->value.set);
            for (i=0; i<count; i++) {
                s = (sk_ASN1_TYPE_value(att->value.set, i)->value.asn1_string);
                XPUSHs(sv_2mortal(newSViv(PTR2IV(s))));
            }
        }
#line 6030 "SSLeay.c"
	PUTBACK;
	return;
    }
}

#endif

XS(XS_Net__SSLeay_P_X509_REQ_add_extensions); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_X509_REQ_add_extensions)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "x, ...");
    {
	X509_REQ *	x = INT2PTR(X509_REQ *,SvIV(ST(0)));
#line 2374 "SSLeay.xs"
        int i=1;
        int nid;
        char *data;
        X509_EXTENSION *ex;
        STACK_OF(X509_EXTENSION) *stack;
#line 6056 "SSLeay.c"
	int	RETVAL;
	dXSTARG;
#line 2380 "SSLeay.xs"
        if (items>1) {
            RETVAL = 1;
            stack = sk_X509_EXTENSION_new_null();
            while(i+1<items) {
                nid = SvIV(ST(i));
                data = SvPV_nolen(ST(i+1));
                i+=2;
                ex = X509V3_EXT_conf_nid(NULL, NULL, nid, data);
                if (ex)
                    sk_X509_EXTENSION_push(stack, ex);
                else
                    RETVAL = 0;
            }
            X509_REQ_add_extensions(x, stack);
            sk_X509_EXTENSION_pop_free(stack, X509_EXTENSION_free);
        }
        else
            RETVAL = 0;
#line 6078 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_P_X509_add_extensions); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_X509_add_extensions)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "x, ca_cert, ...");
    {
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));
	X509 *	ca_cert = INT2PTR(X509 *,SvIV(ST(1)));
#line 2406 "SSLeay.xs"
        int i=2;
        int nid;
        char *data;
        X509_EXTENSION *ex;
        X509V3_CTX ctx;
#line 6104 "SSLeay.c"
	int	RETVAL;
	dXSTARG;
#line 2412 "SSLeay.xs"
        if (items>1) {
            RETVAL = 1;
            while(i+1<items) {
                nid = SvIV(ST(i));
                data = SvPV_nolen(ST(i+1));
                i+=2;
                X509V3_set_ctx(&ctx, ca_cert, x, NULL, NULL, 0);
                ex = X509V3_EXT_conf_nid(NULL, &ctx, nid, data);
                if (ex) {
                    X509_add_ext(x,ex,-1);
                    X509_EXTENSION_free(ex);
                }
                else {
                    warn("failure during X509V3_EXT_conf_nid() for nid=%d\n", nid);
                    ERR_print_errors_fp(stderr);
                    RETVAL = 0;
                }
            }
        }
        else
            RETVAL = 0;
#line 6129 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_P_X509_copy_extensions); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_X509_copy_extensions)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "x509_req, x509, override=1");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	X509_REQ *	x509_req = INT2PTR(X509_REQ *,SvIV(ST(0)));
	X509 *	x509 = INT2PTR(X509 *,SvIV(ST(1)));
	int	override;
#line 2442 "SSLeay.xs"
        STACK_OF(X509_EXTENSION) *exts = NULL;
        X509_EXTENSION *ext, *tmpext;
        ASN1_OBJECT *obj;
        int i, idx, ret = 1;
#line 6157 "SSLeay.c"

	if (items < 3)
	    override = 1;
	else {
	    override = (int)SvIV(ST(2));
	}
#line 2447 "SSLeay.xs"
        if (!x509 || !x509_req) XSRETURN_IV(0);
        exts = X509_REQ_get_extensions(x509_req);
        for(i = 0; i < sk_X509_EXTENSION_num(exts); i++) {
            ext = sk_X509_EXTENSION_value(exts, i);
            obj = X509_EXTENSION_get_object(ext);
            idx = X509_get_ext_by_OBJ(x509, obj, -1);
            /* Does extension exist? */
            if (idx != -1) {
                if (override) continue; /* don't override existing extension */
                /* Delete all extensions of same type */
                do {
                    tmpext = X509_get_ext(x509, idx);
                    X509_delete_ext(x509, idx);
                    X509_EXTENSION_free(tmpext);
                    idx = X509_get_ext_by_OBJ(x509, obj, -1);
                } while (idx != -1);
            }
            if (!X509_add_ext(x509, ext, -1)) ret = 0;
        }
        sk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);
        XSRETURN_IV(ret);
#line 6186 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_X509_STORE_CTX_get_current_cert); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_STORE_CTX_get_current_cert)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x509_store_ctx");
    {
	X509_STORE_CTX *	x509_store_ctx = INT2PTR(X509_STORE_CTX *,SvIV(ST(0)));
	X509 *	RETVAL;
	dXSTARG;

	RETVAL = X509_STORE_CTX_get_current_cert(x509_store_ctx);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_STORE_CTX_get_ex_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_STORE_CTX_get_ex_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x509_store_ctx, idx");
    {
	X509_STORE_CTX *	x509_store_ctx = INT2PTR(X509_STORE_CTX *,SvIV(ST(0)));
	int	idx = (int)SvIV(ST(1));
	void *	RETVAL;
	dXSTARG;

	RETVAL = X509_STORE_CTX_get_ex_data(x509_store_ctx, idx);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_get_fingerprint); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_get_fingerprint)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "cert, type");
    {
	X509 *	cert = INT2PTR(X509 *,SvIV(ST(0)));
	char *	type = (char *)SvPV_nolen(ST(1));
#line 2483 "SSLeay.xs"
		const EVP_MD *digest_tp = NULL;
		unsigned char digest[EVP_MAX_MD_SIZE];
		unsigned int dsz, k = 0;
		char text[EVP_MAX_MD_SIZE * 3 + 1];
#line 6256 "SSLeay.c"
#line 2488 "SSLeay.xs"
		if (!k && !strcmp(type,"md5")) {
		 	k = 1; digest_tp = EVP_md5();
		}
		if (!k && !strcmp(type,"sha1")) {
			k = 1; digest_tp = EVP_sha1();
		}
#if OPENSSL_VERSION_NUMBER >= 0x0090800fL
#ifndef OPENSSL_NO_SHA256
		if (!k && !strcmp(type,"sha256")) {
			k = 1; digest_tp = EVP_sha256();
		}
#endif
#endif
		if (!k && !strcmp(type,"ripemd160")) {
			k = 1; digest_tp = EVP_ripemd160();
		}
		if (!k)	/* Default digest */
			digest_tp = EVP_sha1();
		if ( digest_tp == NULL ) {
			/* Out of memory */
			XSRETURN_UNDEF;
		}
		if (!X509_digest(cert, digest_tp, digest, &dsz)) {
			/* Out of memory */
			XSRETURN_UNDEF;
		}
		text[0] = '\0';
		for(k=0; k<dsz; k++) {
			sprintf(&text[strlen(text)], "%02X:", digest[k]);
		}
		text[strlen(text)-1] = '\0';
		ST(0) = sv_newmortal();   /* Undefined to start with */
		sv_setpvn( ST(0), text, strlen(text));
#line 6291 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_get_subjectAltNames); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_get_subjectAltNames)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	X509 *	cert = INT2PTR(X509 *,SvIV(ST(0)));
#line 2526 "SSLeay.xs"
	int                    i, j, count = 0;
	X509_EXTENSION         *subjAltNameExt = NULL;
	STACK_OF(GENERAL_NAME) *subjAltNameDNs = NULL;
	GENERAL_NAME           *subjAltNameDN  = NULL;
	int                    num_gnames;
	if (  (i = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1)) >= 0
		&& (subjAltNameExt = X509_get_ext(cert, i))
		&& (subjAltNameDNs = X509V3_EXT_d2i(subjAltNameExt)))
	{
		num_gnames = sk_GENERAL_NAME_num(subjAltNameDNs);

		for (j = 0; j < num_gnames; j++)
                {
		     subjAltNameDN = sk_GENERAL_NAME_value(subjAltNameDNs, j);

                     switch (subjAltNameDN->type)
                     {
                     case GEN_OTHERNAME:
                         EXTEND(SP, 2);
                         count++;
                         PUSHs(sv_2mortal(newSViv(subjAltNameDN->type)));
                         PUSHs(sv_2mortal(newSVpv((const char*)ASN1_STRING_data(subjAltNameDN->d.otherName->value->value.utf8string), ASN1_STRING_length(subjAltNameDN->d.otherName->value->value.utf8string))));
                         break;

                     case GEN_EMAIL:
                     case GEN_DNS:
                     case GEN_URI:
                         EXTEND(SP, 2);
                         count++;
                         PUSHs(sv_2mortal(newSViv(subjAltNameDN->type)));
                         PUSHs(sv_2mortal(newSVpv((const char*)ASN1_STRING_data(subjAltNameDN->d.ia5), ASN1_STRING_length(subjAltNameDN->d.ia5))));
                         break;

                     case GEN_DIRNAME:
                         {
                         char * buf = X509_NAME_oneline(subjAltNameDN->d.dirn, NULL, 0);
                         EXTEND(SP, 2);
                         count++;
                         PUSHs(sv_2mortal(newSViv(subjAltNameDN->type)));
                         PUSHs(sv_2mortal(newSVpv((buf), strlen((buf)))));
                         break;
                         }

                     case GEN_IPADD:
                         EXTEND(SP, 2);
                         count++;
                         PUSHs(sv_2mortal(newSViv(subjAltNameDN->type)));
                         PUSHs(sv_2mortal(newSVpv((const char*)subjAltNameDN->d.ip->data, subjAltNameDN->d.ip->length)));
                         break;

                     }
		}
	}
	XSRETURN(count * 2);
#line 6366 "SSLeay.c"
	PUTBACK;
	return;
    }
}

#if OPENSSL_VERSION_NUMBER >= 0x0090700fL
#define XSubPPtmpAAAR 1


XS(XS_Net__SSLeay_P_X509_get_crl_distribution_points); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_X509_get_crl_distribution_points)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	X509 *	cert = INT2PTR(X509 *,SvIV(ST(0)));
#line 2587 "SSLeay.xs"
        GENERAL_NAMES *gnames;
        GENERAL_NAME *gn;
        STACK_OF(DIST_POINT) *points;
        DIST_POINT *p;
        int i, j;
#line 6396 "SSLeay.c"
#line 2593 "SSLeay.xs"
        points = X509_get_ext_d2i(cert, NID_crl_distribution_points, NULL, NULL);
        if (points)
        for (i = 0; i < sk_DIST_POINT_num(points); i++) {
            p = sk_DIST_POINT_value(points, i);
            if (!p->distpoint)
                continue;
            if (p->distpoint->type == 0) {
                /* full name */
                gnames = p->distpoint->name.fullname;
                for (j = 0; j < sk_GENERAL_NAME_num(gnames); j++) {
                    gn = sk_GENERAL_NAME_value(gnames, j);

                    if (gn->type == GEN_URI) {
                        XPUSHs(sv_2mortal(newSVpv((char*)ASN1_STRING_data(gn->d.ia5),ASN1_STRING_length(gn->d.ia5))));
                    }
                }
            }
            else {
                /* relative name - not supported */
                /* XXX-TODO: the code below is just an idea; do not enable it without proper test case
                BIO *bp;
                char *buf;
                int n;
                X509_NAME ntmp;
                ntmp.entries = p->distpoint->name.relativename;
                bp = BIO_new(BIO_s_mem());
                if (bp) {
                    X509_NAME_print_ex(bp, &ntmp, 0, XN_FLAG_RFC2253);
                    n = BIO_ctrl_pending(bp);
                    New(0, buf, n, char);
                    if (buf) {
                        j = BIO_read(bp,buf,n);
                        if (j>=0 && j<=n) XPUSHs(sv_2mortal(newSVpvn(buf,j)));
                        Safefree(buf);
                    }
                    BIO_free(bp);
                }
                */
            }
        }
#line 6438 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_P_X509_get_ext_key_usage); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_X509_get_ext_key_usage)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "cert, format=0");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	X509 *	cert = INT2PTR(X509 *,SvIV(ST(0)));
	int	format;
#line 2639 "SSLeay.xs"
        EXTENDED_KEY_USAGE *extusage;
        int i, nid;
        char buffer[100]; /* openssl doc: a buffer length of 80 should be more than enough to handle any OID encountered in practice */
        ASN1_OBJECT *o;
#line 6465 "SSLeay.c"

	if (items < 2)
	    format = 0;
	else {
	    format = (int)SvIV(ST(1));
	}
#line 2644 "SSLeay.xs"
        extusage = X509_get_ext_d2i(cert, NID_ext_key_usage, NULL, NULL);
        for(i = 0; i < sk_ASN1_OBJECT_num(extusage); i++) {
           o = sk_ASN1_OBJECT_value(extusage,i);
           nid = OBJ_obj2nid(o);
           OBJ_obj2txt(buffer, sizeof(buffer)-1, o, 1);
           if(format==0)
               XPUSHs(sv_2mortal(newSVpv(buffer,0)));          /* format 0: oid */
           else if(format==1 && nid>0)
               XPUSHs(sv_2mortal(newSViv(nid)));               /* format 1: nid */
           else if(format==2 && nid>0)
               XPUSHs(sv_2mortal(newSVpv(OBJ_nid2sn(nid),0))); /* format 2: shortname */
           else if(format==3 && nid>0)
               XPUSHs(sv_2mortal(newSVpv(OBJ_nid2ln(nid),0))); /* format 3: longname */
        }
#line 6487 "SSLeay.c"
	PUTBACK;
	return;
    }
}

#endif

XS(XS_Net__SSLeay_P_X509_get_key_usage); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_X509_get_key_usage)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	X509 *	cert = INT2PTR(X509 *,SvIV(ST(0)));
#line 2665 "SSLeay.xs"
        ASN1_BIT_STRING * u;
#line 6511 "SSLeay.c"
#line 2667 "SSLeay.xs"
        u = X509_get_ext_d2i(cert, NID_key_usage, NULL, NULL);
        if (u) {
            if (ASN1_BIT_STRING_get_bit(u,0)) XPUSHs(sv_2mortal(newSVpv("digitalSignature",0)));
            if (ASN1_BIT_STRING_get_bit(u,1)) XPUSHs(sv_2mortal(newSVpv("nonRepudiation",0)));
            if (ASN1_BIT_STRING_get_bit(u,2)) XPUSHs(sv_2mortal(newSVpv("keyEncipherment",0)));
            if (ASN1_BIT_STRING_get_bit(u,3)) XPUSHs(sv_2mortal(newSVpv("dataEncipherment",0)));
            if (ASN1_BIT_STRING_get_bit(u,4)) XPUSHs(sv_2mortal(newSVpv("keyAgreement",0)));
            if (ASN1_BIT_STRING_get_bit(u,5)) XPUSHs(sv_2mortal(newSVpv("keyCertSign",0)));
            if (ASN1_BIT_STRING_get_bit(u,6)) XPUSHs(sv_2mortal(newSVpv("cRLSign",0)));
            if (ASN1_BIT_STRING_get_bit(u,7)) XPUSHs(sv_2mortal(newSVpv("encipherOnly",0)));
            if (ASN1_BIT_STRING_get_bit(u,8)) XPUSHs(sv_2mortal(newSVpv("decipherOnly",0)));
        }
#line 6525 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_P_X509_get_netscape_cert_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_X509_get_netscape_cert_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	X509 *	cert = INT2PTR(X509 *,SvIV(ST(0)));
#line 2684 "SSLeay.xs"
        ASN1_BIT_STRING * u;
#line 6548 "SSLeay.c"
#line 2686 "SSLeay.xs"
        u = X509_get_ext_d2i(cert, NID_netscape_cert_type, NULL, NULL);
        if (u) {
            if (ASN1_BIT_STRING_get_bit(u,0)) XPUSHs(sv_2mortal(newSVpv("client",0)));
            if (ASN1_BIT_STRING_get_bit(u,1)) XPUSHs(sv_2mortal(newSVpv("server",0)));
            if (ASN1_BIT_STRING_get_bit(u,2)) XPUSHs(sv_2mortal(newSVpv("email",0)));
            if (ASN1_BIT_STRING_get_bit(u,3)) XPUSHs(sv_2mortal(newSVpv("objsign",0)));
            if (ASN1_BIT_STRING_get_bit(u,4)) XPUSHs(sv_2mortal(newSVpv("reserved",0)));
            if (ASN1_BIT_STRING_get_bit(u,5)) XPUSHs(sv_2mortal(newSVpv("sslCA",0)));
            if (ASN1_BIT_STRING_get_bit(u,6)) XPUSHs(sv_2mortal(newSVpv("emailCA",0)));
            if (ASN1_BIT_STRING_get_bit(u,7)) XPUSHs(sv_2mortal(newSVpv("objCA",0)));
        }
#line 6561 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_X509_get_ext_by_NID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_get_ext_by_NID)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "x, nid, loc=-1");
    {
	X509*	x = INT2PTR(X509 *,SvIV(ST(0)));
	int	nid = (int)SvIV(ST(1));
	int	loc;
	int	RETVAL;
	dXSTARG;

	if (items < 3)
	    loc = -1;
	else {
	    loc = (int)SvIV(ST(2));
	}

	RETVAL = X509_get_ext_by_NID(x, nid, loc);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_get_ext); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_get_ext)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, loc");
    {
	X509*	x = INT2PTR(X509 *,SvIV(ST(0)));
	int	loc = (int)SvIV(ST(1));
	X509_EXTENSION *	RETVAL;
	dXSTARG;

	RETVAL = X509_get_ext(x, loc);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_EXTENSION_get_critical); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_EXTENSION_get_critical)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ex");
    {
	int	RETVAL;
	dXSTARG;
	X509_EXTENSION *	ex = INT2PTR(X509_EXTENSION *,SvIV(ST(0)));

	RETVAL = X509_EXTENSION_get_critical(ex);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_EXTENSION_get_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_EXTENSION_get_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ne");
    {
	ASN1_OCTET_STRING *	RETVAL;
	dXSTARG;
	X509_EXTENSION *	ne = INT2PTR(X509_EXTENSION *,SvIV(ST(0)));

	RETVAL = X509_EXTENSION_get_data(ne);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_EXTENSION_get_object); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_EXTENSION_get_object)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ex");
    {
	ASN1_OBJECT *	RETVAL;
	dXSTARG;
	X509_EXTENSION *	ex = INT2PTR(X509_EXTENSION *,SvIV(ST(0)));

	RETVAL = X509_EXTENSION_get_object(ex);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_get_ext_count); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_get_ext_count)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	int	RETVAL;
	dXSTARG;
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));

	RETVAL = X509_get_ext_count(x);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_CRL_get_ext_count); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_get_ext_count)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	int	RETVAL;
	dXSTARG;
	X509_CRL *	x = INT2PTR(X509_CRL *,SvIV(ST(0)));

	RETVAL = X509_CRL_get_ext_count(x);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_CRL_get_ext_by_NID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_get_ext_by_NID)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "x, ni, loc=-1");
    {
	X509_CRL*	x = INT2PTR(X509_CRL *,SvIV(ST(0)));
	int	ni = (int)SvIV(ST(1));
	int	loc;
	int	RETVAL;
	dXSTARG;

	if (items < 3)
	    loc = -1;
	else {
	    loc = (int)SvIV(ST(2));
	}

	RETVAL = X509_CRL_get_ext_by_NID(x, ni, loc);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_CRL_get_ext); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_get_ext)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, loc");
    {
	X509_CRL*	x = INT2PTR(X509_CRL *,SvIV(ST(0)));
	int	loc = (int)SvIV(ST(1));
	X509_EXTENSION *	RETVAL;
	dXSTARG;

	RETVAL = X509_CRL_get_ext(x, loc);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509V3_EXT_print); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509V3_EXT_print)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "ext, flags=0, utf8_decode=0");
    {
	X509_EXTENSION *	ext = INT2PTR(X509_EXTENSION *,SvIV(ST(0)));
	unsigned long	flags;
	int	utf8_decode;
#line 2741 "SSLeay.xs"
        BIO * bp;
        char * buf;
        int i, n;
        int indent=0;
#line 6803 "SSLeay.c"

	if (items < 2)
	    flags = 0;
	else {
	    flags = (unsigned long)SvUV(ST(1));
	}

	if (items < 3)
	    utf8_decode = 0;
	else {
	    utf8_decode = (int)SvIV(ST(2));
	}
#line 2746 "SSLeay.xs"
        ST(0) = sv_newmortal(); /* undef to start with */
        bp = BIO_new(BIO_s_mem());
        if (bp) {
            if(X509V3_EXT_print(bp,ext,flags,indent)) {
                n = BIO_ctrl_pending(bp);
                New(0, buf, n, char);
                if (buf) {
                    i = BIO_read(bp,buf,n);
                    if (i>=0 && i<=n) {
                        sv_setpvn(ST(0), buf, i);
                        if (utf8_decode) sv_utf8_decode(ST(0));
                    }
                    Safefree(buf);
                }
            }
            BIO_free(bp);
        }
#line 6834 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509V3_EXT_d2i); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509V3_EXT_d2i)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ext");
    {
	X509_EXTENSION *	ext = INT2PTR(X509_EXTENSION *,SvIV(ST(0)));
	void *	RETVAL;
	dXSTARG;

	RETVAL = X509V3_EXT_d2i(ext);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_STORE_CTX_get_error); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_STORE_CTX_get_error)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x509_store_ctx");
    {
	X509_STORE_CTX *	x509_store_ctx = INT2PTR(X509_STORE_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_STORE_CTX_get_error(x509_store_ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_STORE_CTX_get_error_depth); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_STORE_CTX_get_error_depth)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x509_store_ctx");
    {
	X509_STORE_CTX *	x509_store_ctx = INT2PTR(X509_STORE_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_STORE_CTX_get_error_depth(x509_store_ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_STORE_CTX_set_ex_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_STORE_CTX_set_ex_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "x509_store_ctx, idx, data");
    {
	X509_STORE_CTX *	x509_store_ctx = INT2PTR(X509_STORE_CTX *,SvIV(ST(0)));
	int	idx = (int)SvIV(ST(1));
	void *	data = INT2PTR(void *,SvIV(ST(2)));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_STORE_CTX_set_ex_data(x509_store_ctx, idx, data);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_STORE_CTX_set_error); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_STORE_CTX_set_error)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x509_store_ctx, s");
    {
	X509_STORE_CTX *	x509_store_ctx = INT2PTR(X509_STORE_CTX *,SvIV(ST(0)));
	int	s = (int)SvIV(ST(1));

	X509_STORE_CTX_set_error(x509_store_ctx, s);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_X509_STORE_CTX_set_cert); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_STORE_CTX_set_cert)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x509_store_ctx, x");
    {
	X509_STORE_CTX *	x509_store_ctx = INT2PTR(X509_STORE_CTX *,SvIV(ST(0)));
	X509 *	x = INT2PTR(X509 *,SvIV(ST(1)));

	X509_STORE_CTX_set_cert(x509_store_ctx, x);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_X509_STORE_add_cert); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_STORE_add_cert)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, x");
    {
	X509_STORE *	ctx = INT2PTR(X509_STORE *,SvIV(ST(0)));
	X509 *	x = INT2PTR(X509 *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_STORE_add_cert(ctx, x);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_STORE_add_crl); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_STORE_add_crl)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, x");
    {
	X509_STORE *	ctx = INT2PTR(X509_STORE *,SvIV(ST(0)));
	X509_CRL *	x = INT2PTR(X509_CRL *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_STORE_add_crl(ctx, x);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x0090800fL
#define XSubPPtmpAAAS 1


XS(XS_Net__SSLeay_X509_STORE_set_flags); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_STORE_set_flags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, flags");
    {
	X509_STORE *	ctx = INT2PTR(X509_STORE *,SvIV(ST(0)));
	long	flags = (long)SvIV(ST(1));

	X509_STORE_set_flags(ctx, flags);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_X509_STORE_set_purpose); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_STORE_set_purpose)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, purpose");
    {
	X509_STORE *	ctx = INT2PTR(X509_STORE *,SvIV(ST(0)));
	int	purpose = (int)SvIV(ST(1));

	X509_STORE_set_purpose(ctx, purpose);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_X509_STORE_set_trust); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_STORE_set_trust)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, trust");
    {
	X509_STORE *	ctx = INT2PTR(X509_STORE *,SvIV(ST(0)));
	int	trust = (int)SvIV(ST(1));

	X509_STORE_set_trust(ctx, trust);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_X509_STORE_set1_param); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_STORE_set1_param)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, pm");
    {
	X509_STORE *	ctx = INT2PTR(X509_STORE *,SvIV(ST(0)));
	X509_VERIFY_PARAM *	pm = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_STORE_set1_param(ctx, pm);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_X509_load_cert_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_load_cert_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ctx, file, type");
    {
	X509_LOOKUP *	ctx = INT2PTR(X509_LOOKUP *,SvIV(ST(0)));
	char *	file = (char *)SvPV_nolen(ST(1));
	int	type = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_load_cert_file(ctx, file, type);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_load_crl_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_load_crl_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ctx, file, type");
    {
	X509_LOOKUP *	ctx = INT2PTR(X509_LOOKUP *,SvIV(ST(0)));
	char *	file = (char *)SvPV_nolen(ST(1));
	int	type = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_load_crl_file(ctx, file, type);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_load_cert_crl_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_load_cert_crl_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ctx, file, type");
    {
	X509_LOOKUP *	ctx = INT2PTR(X509_LOOKUP *,SvIV(ST(0)));
	char *	file = (char *)SvPV_nolen(ST(1));
	int	type = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_load_cert_crl_file(ctx, file, type);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_verify_cert_error_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_verify_cert_error_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "n");
    {
	long	n = (long)SvIV(ST(0));
	const char *	RETVAL;
	dXSTARG;

	RETVAL = X509_verify_cert_error_string(n);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_ASN1_INTEGER_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ASN1_INTEGER_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	ASN1_INTEGER *	RETVAL;
	dXSTARG;

	RETVAL = ASN1_INTEGER_new();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_ASN1_INTEGER_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ASN1_INTEGER_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	ASN1_INTEGER *	i = INT2PTR(ASN1_INTEGER *,SvIV(ST(0)));

	ASN1_INTEGER_free(i);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_ASN1_INTEGER_set); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ASN1_INTEGER_set)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "i, val");
    {
	int	RETVAL;
	dXSTARG;
	ASN1_INTEGER *	i = INT2PTR(ASN1_INTEGER *,SvIV(ST(0)));
	long	val = (long)SvIV(ST(1));

	RETVAL = ASN1_INTEGER_set(i, val);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_ASN1_INTEGER_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ASN1_INTEGER_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "a");
    {
	long	RETVAL;
	dXSTARG;
	ASN1_INTEGER *	a = INT2PTR(ASN1_INTEGER *,SvIV(ST(0)));

	RETVAL = ASN1_INTEGER_get(a);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_P_ASN1_INTEGER_set_hex); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_ASN1_INTEGER_set_hex)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "i, str");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	ASN1_INTEGER *	i = INT2PTR(ASN1_INTEGER *,SvIV(ST(0)));
	char *	str = (char *)SvPV_nolen(ST(1));
#line 2865 "SSLeay.xs"
        BIGNUM *bn;
        int rv = 1;
#line 7300 "SSLeay.c"
#line 2868 "SSLeay.xs"
        bn = BN_new();
        if (!BN_hex2bn(&bn, str)) XSRETURN_IV(0);
        if (!BN_to_ASN1_INTEGER(bn, i)) rv = 0;
        BN_free(bn);
        XSRETURN_IV(rv);
#line 7307 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_P_ASN1_INTEGER_set_dec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_ASN1_INTEGER_set_dec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "i, str");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	ASN1_INTEGER *	i = INT2PTR(ASN1_INTEGER *,SvIV(ST(0)));
	char *	str = (char *)SvPV_nolen(ST(1));
#line 2879 "SSLeay.xs"
        BIGNUM *bn;
        int rv = 1;
#line 7332 "SSLeay.c"
#line 2882 "SSLeay.xs"
        bn = BN_new();
        if (!BN_dec2bn(&bn, str)) XSRETURN_IV(0);
        if (!BN_to_ASN1_INTEGER(bn, i)) rv = 0;
        BN_free(bn);
        XSRETURN_IV(rv);
#line 7339 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_P_ASN1_INTEGER_get_hex); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_ASN1_INTEGER_get_hex)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "i");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	ASN1_INTEGER *	i = INT2PTR(ASN1_INTEGER *,SvIV(ST(0)));
#line 2892 "SSLeay.xs"
        BIGNUM *bn;
        char *result;
#line 7363 "SSLeay.c"
#line 2895 "SSLeay.xs"
        bn = BN_new();
        if (!bn) XSRETURN_UNDEF;
        ASN1_INTEGER_to_BN(i, bn);
        result = BN_bn2hex(bn);
        BN_free(bn);
        if (!result) XSRETURN_UNDEF;
        XPUSHs(sv_2mortal(newSVpv((const char*)result, strlen(result))));
        OPENSSL_free(result);
#line 7373 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_P_ASN1_INTEGER_get_dec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_ASN1_INTEGER_get_dec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "i");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	ASN1_INTEGER *	i = INT2PTR(ASN1_INTEGER *,SvIV(ST(0)));
#line 2908 "SSLeay.xs"
        BIGNUM *bn;
        char *result;
#line 7397 "SSLeay.c"
#line 2911 "SSLeay.xs"
        bn = BN_new();
        if (!bn) XSRETURN_UNDEF;
        ASN1_INTEGER_to_BN(i, bn);
        result = BN_bn2dec(bn);
        BN_free(bn);
        if (!result) XSRETURN_UNDEF;
        XPUSHs(sv_2mortal(newSVpv((const char*)result, strlen(result))));
        OPENSSL_free(result);
#line 7407 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_P_ASN1_STRING_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_ASN1_STRING_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "s, utf8_decode=0");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	ASN1_STRING *	s = INT2PTR(ASN1_STRING *,SvIV(ST(0)));
	int	utf8_decode;
#line 2925 "SSLeay.xs"
        SV * u8;
#line 7431 "SSLeay.c"

	if (items < 2)
	    utf8_decode = 0;
	else {
	    utf8_decode = (int)SvIV(ST(1));
	}
#line 2927 "SSLeay.xs"
        u8 = newSVpv((const char*)ASN1_STRING_data(s), ASN1_STRING_length(s));
        if (utf8_decode) sv_utf8_decode(u8);
        XPUSHs(sv_2mortal(u8));
#line 7442 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_X509_get_notBefore); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_get_notBefore)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    {
	X509 *	cert = INT2PTR(X509 *,SvIV(ST(0)));
	ASN1_TIME *	RETVAL;
	dXSTARG;

	RETVAL = X509_get_notBefore(cert);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_get_notAfter); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_get_notAfter)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    {
	X509 *	cert = INT2PTR(X509 *,SvIV(ST(0)));
	ASN1_TIME *	RETVAL;
	dXSTARG;

	RETVAL = X509_get_notAfter(cert);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_gmtime_adj); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_gmtime_adj)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, adj");
    {
	ASN1_TIME *	s = INT2PTR(ASN1_TIME *,SvIV(ST(0)));
	long	adj = (long)SvIV(ST(1));
	ASN1_TIME *	RETVAL;
	dXSTARG;

	RETVAL = X509_gmtime_adj(s, adj);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_ASN1_TIME_set); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ASN1_TIME_set)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, t");
    {
	ASN1_TIME *	s = INT2PTR(ASN1_TIME *,SvIV(ST(0)));
	time_t	t = (time_t)SvNV(ST(1));
	ASN1_TIME *	RETVAL;
	dXSTARG;

	RETVAL = ASN1_TIME_set(s, t);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_ASN1_TIME_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ASN1_TIME_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	ASN1_TIME *	s = INT2PTR(ASN1_TIME *,SvIV(ST(0)));

	ASN1_TIME_free(s);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_ASN1_TIME_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_ASN1_TIME_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	ASN1_TIME *	RETVAL;
	dXSTARG;

	RETVAL = ASN1_TIME_new();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_P_ASN1_TIME_put2string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_ASN1_TIME_put2string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "tm");
    {
	ASN1_TIME *	tm = INT2PTR(ASN1_TIME *,SvIV(ST(0)));
#line 2960 "SSLeay.xs"
     BIO *bp=NULL;
     int i=0;
     char buffer[256];
#line 7596 "SSLeay.c"
#line 2966 "SSLeay.xs"
     ST(0) = sv_newmortal(); /* undef retval to start with */
     if (tm) {
         bp = BIO_new(BIO_s_mem());
         if (bp) {
             ASN1_TIME_print(bp,tm);
             i = BIO_read(bp,buffer,255);
             buffer[i] = '\0';
             if (i>0)
                 sv_setpvn(ST(0), buffer, i);
             BIO_free(bp);
         }
     }
#line 7610 "SSLeay.c"
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x0090705f
#define REM15 "NOTE: requires 0.9.7e+"
#define XSubPPtmpAAAT 1


XS(XS_Net__SSLeay_P_ASN1_TIME_get_isotime); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_ASN1_TIME_get_isotime)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "tm");
    {
	ASN1_TIME *	tm = INT2PTR(ASN1_TIME *,SvIV(ST(0)));
#line 2986 "SSLeay.xs"
     ASN1_GENERALIZEDTIME *tmp = NULL;
     char buf[256];
#line 7635 "SSLeay.c"
#line 2989 "SSLeay.xs"
     buf[0] = '\0';
     /* ASN1_TIME_to_generalizedtime is buggy on pre-0.9.7e */
     ASN1_TIME_to_generalizedtime(tm,&tmp);
     if (tmp) {
       if (ASN1_GENERALIZEDTIME_check(tmp)) {
         if (strlen((char*)tmp->data)>=14 && strlen((char*)tmp->data)<200) {
           strcpy (buf,"yyyy-mm-ddThh:mm:ss");
           strncpy(buf,   (char*)tmp->data,   4);
           strncpy(buf+5, (char*)tmp->data+4, 2);
           strncpy(buf+8, (char*)tmp->data+6, 2);
           strncpy(buf+11,(char*)tmp->data+8, 2);
           strncpy(buf+14,(char*)tmp->data+10,2);
           strncpy(buf+17,(char*)tmp->data+12,2);
           if (strlen((char*)tmp->data)>14) strcat(buf+19,(char*)tmp->data+14);
         }
       }
       ASN1_GENERALIZEDTIME_free(tmp);
     }
     ST(0) = sv_newmortal();
     sv_setpv(ST(0), buf);
#line 7657 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_P_ASN1_TIME_set_isotime); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_ASN1_TIME_set_isotime)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "tm, str");
    {
	ASN1_TIME *	tm = INT2PTR(ASN1_TIME *,SvIV(ST(0)));
	const char *	str = (const char *)SvPV_nolen(ST(1));
#line 3015 "SSLeay.xs"
     ASN1_TIME t;
     char buf[256];
     int i,rv;
#line 7680 "SSLeay.c"
#line 3019 "SSLeay.xs"
     if (!tm) XSRETURN_UNDEF;
     /* we support only "2012-03-22T23:55:33" or "2012-03-22T23:55:33Z" or "2012-03-22T23:55:33<timezone>" */
     if (strlen(str) < 19) XSRETURN_UNDEF;
     for (i=0;  i<4;  i++) if ((str[i] > '9') || (str[i] < '0')) XSRETURN_UNDEF;
     for (i=5;  i<7;  i++) if ((str[i] > '9') || (str[i] < '0')) XSRETURN_UNDEF;
     for (i=8;  i<10; i++) if ((str[i] > '9') || (str[i] < '0')) XSRETURN_UNDEF;
     for (i=11; i<13; i++) if ((str[i] > '9') || (str[i] < '0')) XSRETURN_UNDEF;
     for (i=14; i<16; i++) if ((str[i] > '9') || (str[i] < '0')) XSRETURN_UNDEF;
     for (i=17; i<19; i++) if ((str[i] > '9') || (str[i] < '0')) XSRETURN_UNDEF;
     strncpy(buf,    str,    4);
     strncpy(buf+4,  str+5,  2);
     strncpy(buf+6,  str+8,  2);
     strncpy(buf+8,  str+11, 2);
     strncpy(buf+10, str+14, 2);
     strncpy(buf+12, str+17, 2);
     buf[14] = '\0';
     if (strlen(str)>19 && strlen(str)<200) strcat(buf,str+19);

     /* WORKAROUND: ASN1_TIME_set_string() not available in 0.9.8 !!!*/
     /* in 1.0.0 we would simply: rv = ASN1_TIME_set_string(tm,buf); */
     t.length = strlen(buf);
     t.data = (unsigned char *)buf;
     t.flags = 0;
     t.type = V_ASN1_UTCTIME;
     if (!ASN1_TIME_check(&t)) {
        t.type = V_ASN1_GENERALIZEDTIME;
        if (!ASN1_TIME_check(&t)) XSRETURN_UNDEF;
     }
     tm->type = t.type;
     tm->flags = t.flags;
     if (!ASN1_STRING_set(tm,t.data,t.length)) XSRETURN_UNDEF;
     rv = 1;

     /* end of ASN1_TIME_set_string() reimplementation */

     ST(0) = sv_newmortal();
     sv_setiv(ST(0), rv); /* 1 = success, undef = failure */
#line 7719 "SSLeay.c"
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_EVP_PKEY_copy_parameters); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_PKEY_copy_parameters)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "to, from");
    {
	EVP_PKEY *	to = INT2PTR(EVP_PKEY *,SvIV(ST(0)));
	EVP_PKEY *	from = INT2PTR(EVP_PKEY *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = EVP_PKEY_copy_parameters(to, from);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_EVP_PKEY_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_PKEY_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	EVP_PKEY *	RETVAL;
	dXSTARG;

	RETVAL = EVP_PKEY_new();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_EVP_PKEY_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_PKEY_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pkey");
    {
	EVP_PKEY *	pkey = INT2PTR(EVP_PKEY *,SvIV(ST(0)));

	EVP_PKEY_free(pkey);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_EVP_PKEY_assign_RSA); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_PKEY_assign_RSA)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "pkey, key");
    {
	int	RETVAL;
	dXSTARG;
	EVP_PKEY *	pkey = INT2PTR(EVP_PKEY *,SvIV(ST(0)));
	RSA *	key = INT2PTR(RSA *,SvIV(ST(1)));

	RETVAL = EVP_PKEY_assign_RSA(pkey, key);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_EVP_PKEY_bits); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_PKEY_bits)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pkey");
    {
	int	RETVAL;
	dXSTARG;
	EVP_PKEY *	pkey = INT2PTR(EVP_PKEY *,SvIV(ST(0)));

	RETVAL = EVP_PKEY_bits(pkey);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_EVP_PKEY_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_PKEY_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pkey");
    {
	int	RETVAL;
	dXSTARG;
	EVP_PKEY *	pkey = INT2PTR(EVP_PKEY *,SvIV(ST(0)));

	RETVAL = EVP_PKEY_size(pkey);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x1000000fL
#define XSubPPtmpAAAU 1


XS(XS_Net__SSLeay_EVP_PKEY_id); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_PKEY_id)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pkey");
    {
	int	RETVAL;
	dXSTARG;
	const EVP_PKEY *	pkey = INT2PTR(const EVP_PKEY *,SvIV(ST(0)));

	RETVAL = EVP_PKEY_id(pkey);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_PEM_get_string_X509); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_PEM_get_string_X509)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x509");
    {
	X509 *	x509 = INT2PTR(X509 *,SvIV(ST(0)));
#line 3090 "SSLeay.xs"
        BIO *bp;
        int i, n;
        char *buf;
#line 7898 "SSLeay.c"
#line 3094 "SSLeay.xs"
        ST(0) = sv_newmortal(); /* undef to start with */
        bp = BIO_new(BIO_s_mem());
        if (bp && x509) {
            PEM_write_bio_X509(bp,x509);
            n = BIO_ctrl_pending(bp);
            New(0, buf, n, char);
            if (buf) {
                i = BIO_read(bp,buf,n);
                if (i>=0 && i<=n) sv_setpvn(ST(0), buf, i);
                Safefree(buf);
            }
            BIO_free(bp);
        }
#line 7913 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_PEM_get_string_X509_REQ); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_PEM_get_string_X509_REQ)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x509_req");
    {
	X509_REQ *	x509_req = INT2PTR(X509_REQ *,SvIV(ST(0)));
#line 3112 "SSLeay.xs"
        BIO *bp;
        int i, n;
        char *buf;
#line 7935 "SSLeay.c"
#line 3116 "SSLeay.xs"
        ST(0) = sv_newmortal(); /* undef to start with */
        bp = BIO_new(BIO_s_mem());
        if (bp && x509_req) {
            PEM_write_bio_X509_REQ(bp,x509_req);
            n = BIO_ctrl_pending(bp);
            New(0, buf, n, char);
            if (buf) {
                i = BIO_read(bp,buf,n);
                if (i>=0 && i<=n) sv_setpvn(ST(0), buf, i);
                Safefree(buf);
            }
            BIO_free(bp);
        }
#line 7950 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_PEM_get_string_X509_CRL); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_PEM_get_string_X509_CRL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x509_crl");
    {
	X509_CRL *	x509_crl = INT2PTR(X509_CRL *,SvIV(ST(0)));
#line 3134 "SSLeay.xs"
        BIO *bp;
        int i, n;
        char *buf;
#line 7972 "SSLeay.c"
#line 3138 "SSLeay.xs"
        ST(0) = sv_newmortal(); /* undef to start with */
        bp = BIO_new(BIO_s_mem());
        if (bp && x509_crl) {
            PEM_write_bio_X509_CRL(bp,x509_crl);
            n = BIO_ctrl_pending(bp);
            New(0, buf, n, char);
            if (buf) {
                i = BIO_read(bp,buf,n);
                if (i>=0 && i<=n) sv_setpvn(ST(0), buf, i);
                Safefree(buf);
            }
            BIO_free(bp);
        }
#line 7987 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_PEM_get_string_PrivateKey); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_PEM_get_string_PrivateKey)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "pk, passwd=NULL, enc_alg=NULL");
    {
	EVP_PKEY *	pk = INT2PTR(EVP_PKEY *,SvIV(ST(0)));
	char *	passwd;
	const EVP_CIPHER *	enc_alg;
#line 3158 "SSLeay.xs"
        BIO *bp;
        int i, n;
        char *buf;
        int passwd_len = 0;
        pem_password_cb * cb = NULL;
        void * u = NULL;
#line 8014 "SSLeay.c"

	if (items < 2)
	    passwd = NULL;
	else {
	    passwd = (char *)SvPV_nolen(ST(1));
	}

	if (items < 3)
	    enc_alg = NULL;
	else {
	    enc_alg = INT2PTR(const EVP_CIPHER *,SvIV(ST(2)));
	}
#line 3165 "SSLeay.xs"
        ST(0) = sv_newmortal(); /* undef to start with */
        bp = BIO_new(BIO_s_mem());
        if (bp && pk) {
            if (passwd) passwd_len = strlen(passwd);
            if (passwd_len>0) {
                /* encrypted key */
                if (!enc_alg)
                    PEM_write_bio_PrivateKey(bp,pk,EVP_des_cbc(),(unsigned char *)passwd,passwd_len,cb,u);
                else
                    PEM_write_bio_PrivateKey(bp,pk,enc_alg,(unsigned char *)passwd,passwd_len,cb,u);
            }
            else {
                /* unencrypted key */
                PEM_write_bio_PrivateKey(bp,pk,NULL,(unsigned char *)passwd,passwd_len,cb,u);
            }
            n = BIO_ctrl_pending(bp);
            New(0, buf, n, char);
            if (buf) {
                i = BIO_read(bp,buf,n);
                if (i>=0 && i<=n) sv_setpvn(ST(0), buf, i);
                Safefree(buf);
            }
            BIO_free(bp);
        }
#line 8052 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_use_PKCS12_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_use_PKCS12_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "ctx, file, password=NULL");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	char *	file = (char *)SvPV_nolen(ST(1));
	char *	password;
#line 3196 "SSLeay.xs"
        PKCS12 *p12;
        EVP_PKEY *private_key;
        X509 *certificate;
        FILE *fp;
#line 8077 "SSLeay.c"
	int	RETVAL;
	dXSTARG;

	if (items < 3)
	    password = NULL;
	else {
	    password = (char *)SvPV_nolen(ST(2));
	}
#line 3201 "SSLeay.xs"
        RETVAL = 0;
        if ((fp = fopen (file, "rb"))) {
#if OPENSSL_VERSION_NUMBER >= 0x0090700fL
            OPENSSL_add_all_algorithms_noconf();
#else
            OpenSSL_add_all_algorithms();
#endif
            if ((p12 = d2i_PKCS12_fp(fp, NULL))) {
                if (PKCS12_parse(p12, password, &private_key, &certificate, NULL)) {
                    if (private_key) {
                        if (SSL_CTX_use_PrivateKey(ctx, private_key)) RETVAL = 1;
                        EVP_PKEY_free(private_key);
                    }
                    if (certificate) {
                        if (SSL_CTX_use_certificate(ctx, certificate)) RETVAL = 1;
                        X509_free(certificate);
                    }
                }
                PKCS12_free(p12);
            }
            if (!RETVAL) ERR_print_errors_fp(stderr);
            fclose(fp);
        }
#line 8110 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_P_PKCS12_load_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_PKCS12_load_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "file, load_chain=0, password=NULL");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	file = (char *)SvPV_nolen(ST(0));
	int	load_chain;
	char *	password;
#line 3233 "SSLeay.xs"
        PKCS12 *p12;
        EVP_PKEY *private_key = NULL;
        X509 *certificate = NULL;
        STACK_OF(X509) *cachain = NULL;
        X509 *x;
        FILE *fp;
        int i, result;
#line 8141 "SSLeay.c"

	if (items < 2)
	    load_chain = 0;
	else {
	    load_chain = (int)SvIV(ST(1));
	}

	if (items < 3)
	    password = NULL;
	else {
	    password = (char *)SvPV_nolen(ST(2));
	}
#line 3241 "SSLeay.xs"
        if ((fp = fopen (file, "rb"))) {
#if OPENSSL_VERSION_NUMBER >= 0x0090700fL
            OPENSSL_add_all_algorithms_noconf();
#else
            OpenSSL_add_all_algorithms();
#endif
            if ((p12 = d2i_PKCS12_fp(fp, NULL))) {
                if(load_chain)
                    result= PKCS12_parse(p12, password, &private_key, &certificate, &cachain);
                else
                    result= PKCS12_parse(p12, password, &private_key, &certificate, NULL);
                if (result) {
                    if (private_key)
                        XPUSHs(sv_2mortal(newSViv(PTR2IV(private_key))));
                    else
                        XPUSHs(sv_2mortal(newSVpv(NULL,0))); /* undef */
                    if (certificate)
                        XPUSHs(sv_2mortal(newSViv(PTR2IV(certificate))));
                    else
                        XPUSHs(sv_2mortal(newSVpv(NULL,0))); /* undef */
                    if (cachain) {
                        for (i=0; i<sk_X509_num(cachain); i++) {
                            x = sk_X509_value(cachain, i);
                            XPUSHs(sv_2mortal(newSViv(PTR2IV(x))));
                        }
                        sk_X509_free(cachain);
                    }
                }
                PKCS12_free(p12);
            }
            fclose(fp);
        }
#line 8187 "SSLeay.c"
	PUTBACK;
	return;
    }
}

#ifndef OPENSSL_NO_MD2
#define XSubPPtmpAAAV 1


XS(XS_Net__SSLeay_MD2); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_MD2)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "data");
    {
#line 3279 "SSLeay.xs"
	STRLEN len;
	unsigned char md[MD2_DIGEST_LENGTH];
	unsigned char * ret;
#line 8212 "SSLeay.c"
	unsigned char*	data = (unsigned char *) SvPV( ST(0), len);
#line 3285 "SSLeay.xs"
	ret = MD2(data,len,md);
	if (ret!=NULL) {
		XSRETURN_PVN((char *) md, MD2_DIGEST_LENGTH);
	} else {
		XSRETURN_UNDEF;
	}
#line 8221 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}

#endif

XS(XS_Net__SSLeay_MD4); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_MD4)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "data");
    {
#line 3297 "SSLeay.xs"
	STRLEN len;
	unsigned char md[MD4_DIGEST_LENGTH];
#line 8242 "SSLeay.c"
	unsigned char*	data = (unsigned char *) SvPV( ST(0), len );
#line 3302 "SSLeay.xs"
	if (MD4(data,len,md)) {
		XSRETURN_PVN((char *) md, MD4_DIGEST_LENGTH);
	} else {
		XSRETURN_UNDEF;
	}
#line 8250 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_MD5); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_MD5)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "data");
    {
#line 3311 "SSLeay.xs"
     STRLEN len;
     unsigned char md[MD5_DIGEST_LENGTH];
#line 8270 "SSLeay.c"
	unsigned char *	data = (unsigned char *) SvPV( ST(0), len);
#line 3316 "SSLeay.xs"
     if (MD5(data,len,md)) {
	  XSRETURN_PVN((char *) md, MD5_DIGEST_LENGTH);
     } else {
	  XSRETURN_UNDEF;
     }
#line 8278 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}

#if OPENSSL_VERSION_NUMBER >= 0x00905000L
#define XSubPPtmpAAAW 1


XS(XS_Net__SSLeay_RIPEMD160); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RIPEMD160)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "data");
    {
#line 3327 "SSLeay.xs"
     STRLEN len;
     unsigned char md[RIPEMD160_DIGEST_LENGTH];
#line 8301 "SSLeay.c"
	unsigned char *	data = (unsigned char *) SvPV( ST(0), len);
#line 3332 "SSLeay.xs"
     if (RIPEMD160(data,len,md)) {
	  XSRETURN_PVN((char *) md, RIPEMD160_DIGEST_LENGTH);
     } else {
	  XSRETURN_UNDEF;
     }
#line 8309 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}

#endif
#if !defined(OPENSSL_NO_SHA)
#define XSubPPtmpAAAX 1


XS(XS_Net__SSLeay_SHA1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SHA1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "data");
    {
#line 3345 "SSLeay.xs"
     STRLEN len;
     unsigned char md[SHA_DIGEST_LENGTH];
#line 8333 "SSLeay.c"
	unsigned char *	data = (unsigned char *) SvPV( ST(0), len);
#line 3350 "SSLeay.xs"
     if (SHA1(data,len,md)) {
	  XSRETURN_PVN((char *) md, SHA_DIGEST_LENGTH);
     } else {
	  XSRETURN_UNDEF;
     }
#line 8341 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}

#endif
#if !defined(OPENSSL_NO_SHA256) && OPENSSL_VERSION_NUMBER >= 0x0090800fL
#define XSubPPtmpAAAY 1


XS(XS_Net__SSLeay_SHA256); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SHA256)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "data");
    {
#line 3362 "SSLeay.xs"
     STRLEN len;
     unsigned char md[SHA256_DIGEST_LENGTH];
#line 8365 "SSLeay.c"
	unsigned char *	data = (unsigned char *) SvPV( ST(0), len);
#line 3367 "SSLeay.xs"
     if (SHA256(data,len,md)) {
	  XSRETURN_PVN((char *) md, SHA256_DIGEST_LENGTH);
     } else {
	  XSRETURN_UNDEF;
     }
#line 8373 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}

#endif
#if !defined(OPENSSL_NO_SHA512) && OPENSSL_VERSION_NUMBER >= 0x0090800fL
#define XSubPPtmpAAAZ 1


XS(XS_Net__SSLeay_SHA512); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SHA512)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "data");
    {
#line 3379 "SSLeay.xs"
     STRLEN len;
     unsigned char md[SHA512_DIGEST_LENGTH];
#line 8397 "SSLeay.c"
	unsigned char *	data = (unsigned char *) SvPV( ST(0), len);
#line 3384 "SSLeay.xs"
     if (SHA512(data,len,md)) {
	  XSRETURN_PVN((char *) md, SHA512_DIGEST_LENGTH);
     } else {
	  XSRETURN_UNDEF;
     }
#line 8405 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}

#endif
#ifndef OPENSSL_NO_SSL2
#if OPENSSL_VERSION_NUMBER < 0x10000000L
#define XSubPPtmpAABA 1


XS(XS_Net__SSLeay_SSLv2_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SSLv2_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const SSL_METHOD *	RETVAL;
	dXSTARG;

	RETVAL = SSLv2_method();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#endif
#endif

XS(XS_Net__SSLeay_SSLv3_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SSLv3_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const SSL_METHOD *	RETVAL;
	dXSTARG;

	RETVAL = SSLv3_method();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_TLSv1_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_TLSv1_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const SSL_METHOD *	RETVAL;
	dXSTARG;

	RETVAL = TLSv1_method();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#ifdef SSL_TXT_TLSV1_1
#define XSubPPtmpAABB 1


XS(XS_Net__SSLeay_TLSv1_1_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_TLSv1_1_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const SSL_METHOD *	RETVAL;
	dXSTARG;

	RETVAL = TLSv1_1_method();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#endif
#ifdef SSL_TXT_TLSV1_2
#define XSubPPtmpAABC 1


XS(XS_Net__SSLeay_TLSv1_2_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_TLSv1_2_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const SSL_METHOD *	RETVAL;
	dXSTARG;

	RETVAL = TLSv1_2_method();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#endif
#if OPENSSL_VERSION_NUMBER < 0x10000000L
#define XSubPPtmpAABD 1


XS(XS_Net__SSLeay_set_ssl_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_ssl_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, method");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	SSL_METHOD *	method = INT2PTR(SSL_METHOD *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_set_ssl_method(ssl, method);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAABE 1


XS(XS_Net__SSLeay_set_ssl_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_ssl_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, method");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	const SSL_METHOD *	method = INT2PTR(const SSL_METHOD *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_set_ssl_method(ssl, method);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_get_ssl_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_ssl_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	const SSL_METHOD *	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_ssl_method(ssl);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#define REM_AUTOMATICALLY_GENERATED_1_09

XS(XS_Net__SSLeay_BIO_new_buffer_ssl_connect); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_new_buffer_ssl_connect)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	BIO *	RETVAL;
	dXSTARG;

	RETVAL = BIO_new_buffer_ssl_connect(ctx);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_BIO_new_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_new_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "filename, mode");
    {
	char *	filename = (char *)SvPV_nolen(ST(0));
	char *	mode = (char *)SvPV_nolen(ST(1));
	BIO *	RETVAL;
	dXSTARG;

	RETVAL = BIO_new_file(filename, mode);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_BIO_new_ssl); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_new_ssl)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, client");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	client = (int)SvIV(ST(1));
	BIO *	RETVAL;
	dXSTARG;

	RETVAL = BIO_new_ssl(ctx, client);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_BIO_new_ssl_connect); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_new_ssl_connect)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	BIO *	RETVAL;
	dXSTARG;

	RETVAL = BIO_new_ssl_connect(ctx);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_BIO_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "type");
    {
	BIO_METHOD *	type = INT2PTR(BIO_METHOD *,SvIV(ST(0)));
	BIO *	RETVAL;
	dXSTARG;

	RETVAL = BIO_new(type);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_BIO_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bio");
    {
	BIO *	bio = INT2PTR(BIO *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = BIO_free(bio);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_BIO_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "s, max=32768");
    {
	BIO *	s = INT2PTR(BIO *,SvIV(ST(0)));
	int	max;
#line 3475 "SSLeay.xs"
	char *buf = NULL;
	int got;
#line 8757 "SSLeay.c"

	if (items < 2)
	    max = 32768;
	else {
	    max = (int)SvIV(ST(1));
	}
#line 3478 "SSLeay.xs"
	New(0, buf, max, char);
	ST(0) = sv_newmortal();   /* Undefined to start with */
	if ((got = BIO_read(s, buf, max)) >= 0)
		sv_setpvn( ST(0), buf, got);
	Safefree(buf);
#line 8770 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_BIO_write); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_write)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, buf");
    {
	BIO *	s = INT2PTR(BIO *,SvIV(ST(0)));
#line 3488 "SSLeay.xs"
     STRLEN len;
#line 8790 "SSLeay.c"
	char *	buf = SvPV( ST(1), len);
	int	RETVAL;
	dXSTARG;
#line 3492 "SSLeay.xs"
     RETVAL = BIO_write (s, buf, (int)len);
#line 8796 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_BIO_eof); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_eof)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	BIO *	s = INT2PTR(BIO *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = BIO_eof(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_BIO_pending); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_pending)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	BIO *	s = INT2PTR(BIO *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = BIO_pending(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_BIO_wpending); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_wpending)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	BIO *	s = INT2PTR(BIO *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = BIO_wpending(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_BIO_ssl_copy_session_id); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_ssl_copy_session_id)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "to, from");
    {
	BIO *	to = INT2PTR(BIO *,SvIV(ST(0)));
	BIO *	from = INT2PTR(BIO *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = BIO_ssl_copy_session_id(to, from);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_BIO_ssl_shutdown); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_BIO_ssl_shutdown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl_bio");
    {
	BIO *	ssl_bio = INT2PTR(BIO *,SvIV(ST(0)));

	BIO_ssl_shutdown(ssl_bio);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_add_client_CA); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_add_client_CA)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, x");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	X509 *	x = INT2PTR(X509 *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_add_client_CA(ssl, x);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_alert_desc_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_alert_desc_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "value");
    {
	int	value = (int)SvIV(ST(0));
	const char *	RETVAL;
	dXSTARG;

	RETVAL = SSL_alert_desc_string(value);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_alert_desc_string_long); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_alert_desc_string_long)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "value");
    {
	int	value = (int)SvIV(ST(0));
	const char *	RETVAL;
	dXSTARG;

	RETVAL = SSL_alert_desc_string_long(value);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_alert_type_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_alert_type_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "value");
    {
	int	value = (int)SvIV(ST(0));
	const char *	RETVAL;
	dXSTARG;

	RETVAL = SSL_alert_type_string(value);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_alert_type_string_long); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_alert_type_string_long)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "value");
    {
	int	value = (int)SvIV(ST(0));
	const char *	RETVAL;
	dXSTARG;

	RETVAL = SSL_alert_type_string_long(value);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_callback_ctrl); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_callback_ctrl)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ssl, i, fp");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	int	i = (int)SvIV(ST(1));
	callback_no_ret *	fp = INT2PTR(callback_no_ret *,SvIV(ST(2)));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_callback_ctrl(ssl, i, fp);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_check_private_key); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_check_private_key)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL *	ctx = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_check_private_key(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER < 0x009080dfL
#define REM8 "NOTE: before 0.9.8m"
#define XSubPPtmpAABF 1


XS(XS_Net__SSLeay_CIPHER_description); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CIPHER_description)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "cipher, buf, size");
    {
	SSL_CIPHER *	cipher = INT2PTR(SSL_CIPHER *,SvIV(ST(0)));
	char *	buf = (char *)SvPV_nolen(ST(1));
	int	size = (int)SvIV(ST(2));
	char *	RETVAL;
	dXSTARG;

	RETVAL = SSL_CIPHER_description(cipher, buf, size);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAABG 1


XS(XS_Net__SSLeay_CIPHER_description); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CIPHER_description)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "cipher, buf, size");
    {
	const SSL_CIPHER *	cipher = INT2PTR(const SSL_CIPHER *,SvIV(ST(0)));
	char *	buf = (char *)SvPV_nolen(ST(1));
	int	size = (int)SvIV(ST(2));
	char *	RETVAL;
	dXSTARG;

	RETVAL = SSL_CIPHER_description(cipher, buf, size);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#endif
#if OPENSSL_VERSION_NUMBER < 0x0090707fL
#define REM9 "NOTE: before 0.9.7g"
#define XSubPPtmpAABH 1


XS(XS_Net__SSLeay_CIPHER_get_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CIPHER_get_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "c");
    {
	const char *	RETVAL;
	dXSTARG;
	SSL_CIPHER *	c = INT2PTR(SSL_CIPHER *,SvIV(ST(0)));

	RETVAL = SSL_CIPHER_get_name(c);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CIPHER_get_bits); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CIPHER_get_bits)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "c, alg_bits=NULL");
    {
	SSL_CIPHER *	c = INT2PTR(SSL_CIPHER *,SvIV(ST(0)));
	int *	alg_bits;
	int	RETVAL;
	dXSTARG;

	if (items < 2)
	    alg_bits = NULL;
	else {
	    alg_bits = INT2PTR(int *,SvIV(ST(1)));
	}

	RETVAL = SSL_CIPHER_get_bits(c, alg_bits);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAABI 1


XS(XS_Net__SSLeay_CIPHER_get_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CIPHER_get_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "c");
    {
	const char *	RETVAL;
	dXSTARG;
	const SSL_CIPHER *	c = INT2PTR(const SSL_CIPHER *,SvIV(ST(0)));

	RETVAL = SSL_CIPHER_get_name(c);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CIPHER_get_bits); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CIPHER_get_bits)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "c, alg_bits=NULL");
    {
	const SSL_CIPHER *	c = INT2PTR(const SSL_CIPHER *,SvIV(ST(0)));
	int *	alg_bits;
	int	RETVAL;
	dXSTARG;

	if (items < 2)
	    alg_bits = NULL;
	else {
	    alg_bits = INT2PTR(int *,SvIV(ST(1)));
	}

	RETVAL = SSL_CIPHER_get_bits(c, alg_bits);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_COMP_add_compression_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_COMP_add_compression_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "id, cm");
    {
	int	id = (int)SvIV(ST(0));
	COMP_METHOD *	cm = INT2PTR(COMP_METHOD *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_COMP_add_compression_method(id, cm);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_add_client_CA); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_add_client_CA)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, x");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	X509 *	x = INT2PTR(X509 *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_add_client_CA(ctx, x);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_callback_ctrl); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_callback_ctrl)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ctx, i, fp");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	i = (int)SvIV(ST(1));
	callback_no_ret *	fp = INT2PTR(callback_no_ret *,SvIV(ST(2)));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_callback_ctrl(ctx, i, fp);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_check_private_key); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_check_private_key)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_check_private_key(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_get_ex_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_get_ex_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, idx");
    {
	SSL_CTX *	ssl = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	idx = (int)SvIV(ST(1));
	void *	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_get_ex_data(ssl, idx);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_get_quiet_shutdown); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_get_quiet_shutdown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_get_quiet_shutdown(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_get_timeout); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_get_timeout)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_get_timeout(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_get_verify_depth); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_get_verify_depth)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_get_verify_depth(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_get_verify_mode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_get_verify_mode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_get_verify_mode(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_cert_store); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_cert_store)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, store");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	X509_STORE *	store = INT2PTR(X509_STORE *,SvIV(ST(1)));

	SSL_CTX_set_cert_store(ctx, store);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_CTX_get_cert_store); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_get_cert_store)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	X509_STORE *	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_get_cert_store(ctx);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_cert_verify_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_cert_verify_callback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "ctx, callback, data=&PL_sv_undef");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	SV *	callback = ST(1);
	SV *	data;

	if (items < 3)
	    data = &PL_sv_undef;
	else {
	    data = ST(2);
	}
#line 3646 "SSLeay.xs"
        if (callback==NULL || !SvOK(callback)) {
            SSL_CTX_set_cert_verify_callback(ctx, NULL, NULL);
            cb_data_advanced_put(ctx, "ssleay_ctx_cert_verify_cb!!func", NULL);
            cb_data_advanced_put(ctx, "ssleay_ctx_cert_verify_cb!!data", NULL);
        }
        else {
            cb_data_advanced_put(ctx, "ssleay_ctx_cert_verify_cb!!func", newSVsv(callback));
            cb_data_advanced_put(ctx, "ssleay_ctx_cert_verify_cb!!data", newSVsv(data));
#if OPENSSL_VERSION_NUMBER >= 0x0090700fL
            SSL_CTX_set_cert_verify_callback(ctx, ssleay_ctx_cert_verify_cb_invoke, ctx);
#else
            SSL_CTX_set_cert_verify_callback(ctx, ssleay_ctx_cert_verify_cb_invoke, (char*)ctx);
#endif
        }
#line 9514 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_CTX_get_client_CA_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_get_client_CA_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	X509_NAME_STACK *	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_get_client_CA_list(ctx);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_client_CA_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_client_CA_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, list");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	X509_NAME_STACK *	list = INT2PTR(X509_NAME_STACK *,SvIV(ST(1)));

	SSL_CTX_set_client_CA_list(ctx, list);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_CTX_set_default_passwd_cb); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_default_passwd_cb)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "ctx, callback=&PL_sv_undef");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	SV *	callback;

	if (items < 2)
	    callback = &PL_sv_undef;
	else {
	    callback = ST(1);
	}
#line 3675 "SSLeay.xs"
        if (callback==NULL || !SvOK(callback)) {
            SSL_CTX_set_default_passwd_cb(ctx, NULL);
            SSL_CTX_set_default_passwd_cb_userdata(ctx, NULL);
            cb_data_advanced_put(ctx, "ssleay_ctx_passwd_cb!!func", NULL);
        }
        else {
            cb_data_advanced_put(ctx, "ssleay_ctx_passwd_cb!!func", newSVsv(callback));
            SSL_CTX_set_default_passwd_cb_userdata(ctx, (void*)ctx);
            SSL_CTX_set_default_passwd_cb(ctx, &ssleay_ctx_passwd_cb_invoke);
        }
#line 9592 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_CTX_set_default_passwd_cb_userdata); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_default_passwd_cb_userdata)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "ctx, data=&PL_sv_undef");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	SV *	data;

	if (items < 2)
	    data = &PL_sv_undef;
	else {
	    data = ST(1);
	}
#line 3691 "SSLeay.xs"
        /* SSL_CTX_set_default_passwd_cb_userdata is set in SSL_CTX_set_default_passwd_cb */
        if (data==NULL || !SvOK(data)) {
            cb_data_advanced_put(ctx, "ssleay_ctx_passwd_cb!!data", NULL);
        }
        else {
            cb_data_advanced_put(ctx, "ssleay_ctx_passwd_cb!!data", newSVsv(data));
        }
#line 9625 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_CTX_set_ex_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_ex_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ssl, idx, data");
    {
	SSL_CTX *	ssl = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	idx = (int)SvIV(ST(1));
	void *	data = INT2PTR(void *,SvIV(ST(2)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_set_ex_data(ssl, idx, data);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_purpose); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_purpose)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, purpose");
    {
	SSL_CTX *	s = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	purpose = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_set_purpose(s, purpose);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_quiet_shutdown); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_quiet_shutdown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, mode");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	mode = (int)SvIV(ST(1));

	SSL_CTX_set_quiet_shutdown(ctx, mode);
    }
    XSRETURN_EMPTY;
}

#if OPENSSL_VERSION_NUMBER < 0x10000000L
#define XSubPPtmpAABJ 1


XS(XS_Net__SSLeay_CTX_set_ssl_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_ssl_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, meth");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	SSL_METHOD *	meth = INT2PTR(SSL_METHOD *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_set_ssl_version(ctx, meth);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAABK 1


XS(XS_Net__SSLeay_CTX_set_ssl_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_ssl_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, meth");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	const SSL_METHOD *	meth = INT2PTR(const SSL_METHOD *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_set_ssl_version(ctx, meth);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_CTX_set_timeout); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_timeout)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, t");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	long	t = (long)SvIV(ST(1));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_set_timeout(ctx, t);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_trust); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_trust)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, trust");
    {
	SSL_CTX *	s = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	trust = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_set_trust(s, trust);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_verify_depth); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_verify_depth)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, depth");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	int	depth = (int)SvIV(ST(1));

	SSL_CTX_set_verify_depth(ctx, depth);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_CTX_use_certificate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_use_certificate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, x");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	X509 *	x = INT2PTR(X509 *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_use_certificate(ctx, x);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_use_certificate_chain_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_use_certificate_chain_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, file");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	const char *	file = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_use_certificate_chain_file(ctx, file);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_use_PrivateKey); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_use_PrivateKey)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, pkey");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	EVP_PKEY *	pkey = INT2PTR(EVP_PKEY *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_use_PrivateKey(ctx, pkey);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_use_RSAPrivateKey); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_use_RSAPrivateKey)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, rsa");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	RSA *	rsa = INT2PTR(RSA *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_use_RSAPrivateKey(ctx, rsa);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_do_handshake); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_do_handshake)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_do_handshake(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_dup); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_dup)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	SSL *	RETVAL;
	dXSTARG;

	RETVAL = SSL_dup(ssl);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_current_cipher); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_current_cipher)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	const SSL_CIPHER *	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_current_cipher(s);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_default_timeout); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_default_timeout)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_default_timeout(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_ex_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_ex_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, idx");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	int	idx = (int)SvIV(ST(1));
	void *	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_ex_data(ssl, idx);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_finished); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_finished)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "s, buf, count");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	void *	buf = INT2PTR(void *,SvIV(ST(1)));
	size_t	count = (size_t)SvUV(ST(2));
	size_t	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_finished(s, buf, count);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_peer_finished); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_peer_finished)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "s, buf, count");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	void *	buf = INT2PTR(void *,SvIV(ST(1)));
	size_t	count = (size_t)SvUV(ST(2));
	size_t	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_peer_finished(s, buf, count);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_quiet_shutdown); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_quiet_shutdown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_quiet_shutdown(ssl);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_shutdown); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_shutdown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_shutdown(ssl);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_verify_depth); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_verify_depth)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_verify_depth(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_verify_mode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_verify_mode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_verify_mode(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_verify_result); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_verify_result)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_verify_result(ssl);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_renegotiate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_renegotiate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_renegotiate(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER < 0x10000000L
#define XSubPPtmpAABL 1


XS(XS_Net__SSLeay_SESSION_cmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_cmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "a, b");
    {
	SSL_SESSION *	a = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	SSL_SESSION *	b = INT2PTR(SSL_SESSION *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_SESSION_cmp(a, b);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_SESSION_get_ex_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_get_ex_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ss, idx");
    {
	SSL_SESSION *	ss = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	int	idx = (int)SvIV(ST(1));
	void *	RETVAL;
	dXSTARG;

	RETVAL = SSL_SESSION_get_ex_data(ss, idx);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SESSION_get_time); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_get_time)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL_SESSION *	s = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_SESSION_get_time(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SESSION_get_timeout); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_get_timeout)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL_SESSION *	s = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_SESSION_get_timeout(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SESSION_print_fp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_print_fp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "fp, ses");
    {
	FILE *	fp = PerlIO_findFILE(IoIFP(sv_2io(ST(0))));
	SSL_SESSION *	ses = INT2PTR(SSL_SESSION *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_SESSION_print_fp(fp, ses);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SESSION_set_ex_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_set_ex_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ss, idx, data");
    {
	SSL_SESSION *	ss = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	int	idx = (int)SvIV(ST(1));
	void *	data = INT2PTR(void *,SvIV(ST(2)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_SESSION_set_ex_data(ss, idx, data);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SESSION_set_time); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_set_time)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, t");
    {
	SSL_SESSION *	s = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	long	t = (long)SvIV(ST(1));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_SESSION_set_time(s, t);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SESSION_set_timeout); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_set_timeout)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, t");
    {
	SSL_SESSION *	s = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	long	t = (long)SvIV(ST(1));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_SESSION_set_timeout(s, t);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_accept_state); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_accept_state)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));

	SSL_set_accept_state(s);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_sk_X509_NAME_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_sk_X509_NAME_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sk");
    {
	X509_NAME_STACK *	sk = INT2PTR(X509_NAME_STACK *,SvIV(ST(0)));

	sk_X509_NAME_free(sk);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_sk_X509_NAME_num); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_sk_X509_NAME_num)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sk");
    {
	X509_NAME_STACK *	sk = INT2PTR(X509_NAME_STACK *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = sk_X509_NAME_num(sk);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_sk_X509_NAME_value); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_sk_X509_NAME_value)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "sk, i");
    {
	X509_NAME_STACK *	sk = INT2PTR(X509_NAME_STACK *,SvIV(ST(0)));
	int	i = (int)SvIV(ST(1));
	X509_NAME *	RETVAL;
	dXSTARG;

	RETVAL = sk_X509_NAME_value(sk, i);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_client_CA_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_client_CA_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	X509_NAME_STACK *	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_client_CA_list(s);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_client_CA_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_client_CA_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, list");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	X509_NAME_STACK *	list = INT2PTR(X509_NAME_STACK *,SvIV(ST(1)));

	SSL_set_client_CA_list(s, list);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_set_connect_state); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_connect_state)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));

	SSL_set_connect_state(s);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_set_ex_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_ex_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ssl, idx, data");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	int	idx = (int)SvIV(ST(1));
	void *	data = INT2PTR(void *,SvIV(ST(2)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_set_ex_data(ssl, idx, data);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_info_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_info_callback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, cb");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	cb_ssl_int_int_ret_void *	cb = INT2PTR(cb_ssl_int_int_ret_void *,SvIV(ST(1)));

	SSL_set_info_callback(ssl, cb);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_set_purpose); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_purpose)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, purpose");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	purpose = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_set_purpose(s, purpose);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_quiet_shutdown); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_quiet_shutdown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, mode");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	int	mode = (int)SvIV(ST(1));

	SSL_set_quiet_shutdown(ssl, mode);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_set_shutdown); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_shutdown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, mode");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	int	mode = (int)SvIV(ST(1));

	SSL_set_shutdown(ssl, mode);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_set_trust); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_trust)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, trust");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	trust = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_set_trust(s, trust);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_verify_depth); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_verify_depth)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, depth");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	depth = (int)SvIV(ST(1));

	SSL_set_verify_depth(s, depth);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_set_verify_result); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_verify_result)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, v");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	long	v = (long)SvIV(ST(1));

	SSL_set_verify_result(ssl, v);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_shutdown); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_shutdown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_shutdown(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_version(ssl);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define REM_MANUALLY_ADDED_1_09

XS(XS_Net__SSLeay_load_client_CA_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_load_client_CA_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "file");
    {
	const char *	file = (const char *)SvPV_nolen(ST(0));
	X509_NAME_STACK *	RETVAL;
	dXSTARG;

	RETVAL = SSL_load_client_CA_file(file);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_add_file_cert_subjects_to_stack); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_add_file_cert_subjects_to_stack)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "stackCAs, file");
    {
	X509_NAME_STACK *	stackCAs = INT2PTR(X509_NAME_STACK *,SvIV(ST(0)));
	const char *	file = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_add_file_cert_subjects_to_stack(stackCAs, file);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifndef WIN32
#ifndef VMS
#ifndef MAC_OS_pre_X
#define XSubPPtmpAABM 1


XS(XS_Net__SSLeay_add_dir_cert_subjects_to_stack); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_add_dir_cert_subjects_to_stack)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "stackCAs, dir");
    {
	X509_NAME_STACK *	stackCAs = INT2PTR(X509_NAME_STACK *,SvIV(ST(0)));
	const char *	dir = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_add_dir_cert_subjects_to_stack(stackCAs, dir);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif
#endif
#endif

XS(XS_Net__SSLeay_CTX_get_ex_new_index); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_get_ex_new_index)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "argl, argp, new_func, dup_func, free_func");
    {
	long	argl = (long)SvIV(ST(0));
	void *	argp = INT2PTR(void *,SvIV(ST(1)));
	CRYPTO_EX_new *	new_func = INT2PTR(CRYPTO_EX_new *,SvIV(ST(2)));
	CRYPTO_EX_dup *	dup_func = INT2PTR(CRYPTO_EX_dup *,SvIV(ST(3)));
	CRYPTO_EX_free *	free_func = INT2PTR(CRYPTO_EX_free *,SvIV(ST(4)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_get_ex_new_index(argl, argp, new_func, dup_func, free_func);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_session_id_context); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_session_id_context)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ctx, sid_ctx, sid_ctx_len");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	const unsigned char *	sid_ctx = (const unsigned char *)SvPV_nolen(ST(1));
	unsigned int	sid_ctx_len = (unsigned int)SvUV(ST(2));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_set_session_id_context(ctx, sid_ctx, sid_ctx_len);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_session_id_context); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_session_id_context)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ssl, sid_ctx, sid_ctx_len");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	const unsigned char *	sid_ctx = (const unsigned char *)SvPV_nolen(ST(1));
	unsigned int	sid_ctx_len = (unsigned int)SvUV(ST(2));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_set_session_id_context(ssl, sid_ctx, sid_ctx_len);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_tmp_rsa_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_tmp_rsa_callback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, cb");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	cb_ssl_int_int_ret_RSA *	cb = INT2PTR(cb_ssl_int_int_ret_RSA *,SvIV(ST(1)));

	SSL_CTX_set_tmp_rsa_callback(ctx, cb);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_set_tmp_rsa_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_tmp_rsa_callback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, cb");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	cb_ssl_int_int_ret_RSA *	cb = INT2PTR(cb_ssl_int_int_ret_RSA *,SvIV(ST(1)));

	SSL_set_tmp_rsa_callback(ssl, cb);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_CTX_set_tmp_dh_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_tmp_dh_callback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, dh");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	cb_ssl_int_int_ret_DH *	dh = INT2PTR(cb_ssl_int_int_ret_DH *,SvIV(ST(1)));

	SSL_CTX_set_tmp_dh_callback(ctx, dh);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_set_tmp_dh_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_tmp_dh_callback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, dh");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	cb_ssl_int_int_ret_DH *	dh = INT2PTR(cb_ssl_int_int_ret_DH *,SvIV(ST(1)));

	SSL_set_tmp_dh_callback(ssl, dh);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_get_ex_new_index); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_ex_new_index)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "argl, argp, new_func, dup_func, free_func");
    {
	long	argl = (long)SvIV(ST(0));
	void *	argp = INT2PTR(void *,SvIV(ST(1)));
	CRYPTO_EX_new *	new_func = INT2PTR(CRYPTO_EX_new *,SvIV(ST(2)));
	CRYPTO_EX_dup *	dup_func = INT2PTR(CRYPTO_EX_dup *,SvIV(ST(3)));
	CRYPTO_EX_free *	free_func = INT2PTR(CRYPTO_EX_free *,SvIV(ST(4)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_get_ex_new_index(argl, argp, new_func, dup_func, free_func);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SESSION_get_ex_new_index); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_get_ex_new_index)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "argl, argp, new_func, dup_func, free_func");
    {
	long	argl = (long)SvIV(ST(0));
	void *	argp = INT2PTR(void *,SvIV(ST(1)));
	CRYPTO_EX_new *	new_func = INT2PTR(CRYPTO_EX_new *,SvIV(ST(2)));
	CRYPTO_EX_dup *	dup_func = INT2PTR(CRYPTO_EX_dup *,SvIV(ST(3)));
	CRYPTO_EX_free *	free_func = INT2PTR(CRYPTO_EX_free *,SvIV(ST(4)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_SESSION_get_ex_new_index(argl, argp, new_func, dup_func, free_func);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define REM_SEMIAUTOMATIC_MACRO_GEN_1_09

XS(XS_Net__SSLeay_clear_num_renegotiations); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_clear_num_renegotiations)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;
#line 4031 "SSLeay.xs"
  RETVAL = SSL_ctrl(ssl,SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS,0,NULL);
#line 11045 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_add_extra_chain_cert); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_add_extra_chain_cert)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, x509");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	X509 *	x509 = INT2PTR(X509 *,SvIV(ST(1)));
	long	RETVAL;
	dXSTARG;
#line 4040 "SSLeay.xs"
  RETVAL = SSL_CTX_ctrl(ctx,SSL_CTRL_EXTRA_CHAIN_CERT,0,(char*)x509);
#line 11069 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_get_app_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_get_app_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	void *	RETVAL;
	dXSTARG;
#line 4048 "SSLeay.xs"
  RETVAL = SSL_CTX_get_ex_data(ctx,0);
#line 11092 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_get_mode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_get_mode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;
#line 4056 "SSLeay.xs"
  RETVAL = SSL_CTX_ctrl(ctx,SSL_CTRL_MODE,0,NULL);
#line 11115 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_get_read_ahead); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_get_read_ahead)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;
#line 4064 "SSLeay.xs"
  RETVAL = SSL_CTX_ctrl(ctx,SSL_CTRL_GET_READ_AHEAD,0,NULL);
#line 11138 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_get_session_cache_mode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_get_session_cache_mode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;
#line 4072 "SSLeay.xs"
  RETVAL = SSL_CTX_ctrl(ctx,SSL_CTRL_GET_SESS_CACHE_MODE,0,NULL);
#line 11161 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_need_tmp_RSA); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_need_tmp_RSA)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;
#line 4080 "SSLeay.xs"
  RETVAL = SSL_CTX_ctrl(ctx,SSL_CTRL_NEED_TMP_RSA,0,NULL);
#line 11184 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_app_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_app_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, arg");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	char *	arg = (char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;
#line 4089 "SSLeay.xs"
  RETVAL = SSL_CTX_set_ex_data(ctx,0,arg);
#line 11208 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_mode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_mode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, op");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	long	op = (long)SvIV(ST(1));
	long	RETVAL;
	dXSTARG;
#line 4098 "SSLeay.xs"
  RETVAL = SSL_CTX_ctrl(ctx,SSL_CTRL_MODE,op,NULL);
#line 11232 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_read_ahead); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_read_ahead)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, m");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	long	m = (long)SvIV(ST(1));
	long	RETVAL;
	dXSTARG;
#line 4107 "SSLeay.xs"
  RETVAL = SSL_CTX_ctrl(ctx,SSL_CTRL_SET_READ_AHEAD,m,NULL);
#line 11256 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_session_cache_mode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_session_cache_mode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, m");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	long	m = (long)SvIV(ST(1));
	long	RETVAL;
	dXSTARG;
#line 4116 "SSLeay.xs"
  RETVAL = SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SESS_CACHE_MODE,m,NULL);
#line 11280 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_tmp_dh); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_tmp_dh)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, dh");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	DH *	dh = INT2PTR(DH *,SvIV(ST(1)));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_set_tmp_dh(ctx, dh);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_tmp_rsa); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_tmp_rsa)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, rsa");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	RSA *	rsa = INT2PTR(RSA *,SvIV(ST(1)));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_set_tmp_rsa(ctx, rsa);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_app_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_app_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	void *	RETVAL;
	dXSTARG;
#line 4134 "SSLeay.xs"
  RETVAL = SSL_get_ex_data(s,0);
#line 11349 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_cipher_bits); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_cipher_bits)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "s, np=NULL");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int *	np;
	int	RETVAL;
	dXSTARG;

	if (items < 2)
	    np = NULL;
	else {
	    np = INT2PTR(int *,SvIV(ST(1)));
	}
#line 4143 "SSLeay.xs"
  RETVAL = SSL_CIPHER_get_bits(SSL_get_current_cipher(s),np);
#line 11379 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_mode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_mode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;
#line 4151 "SSLeay.xs"
  RETVAL = SSL_ctrl(ssl,SSL_CTRL_MODE,0,NULL);
#line 11402 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_state); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_state)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;
#line 4159 "SSLeay.xs"
  RETVAL = SSL_state(ssl);
#line 11425 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_need_tmp_RSA); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_need_tmp_RSA)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;
#line 4167 "SSLeay.xs"
  RETVAL = SSL_ctrl(ssl,SSL_CTRL_NEED_TMP_RSA,0,NULL);
#line 11448 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_num_renegotiations); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_num_renegotiations)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;
#line 4175 "SSLeay.xs"
  RETVAL = SSL_ctrl(ssl,SSL_CTRL_GET_NUM_RENEGOTIATIONS,0,NULL);
#line 11471 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SESSION_get_app_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_get_app_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ses");
    {
	SSL_SESSION *	ses = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	void *	RETVAL;
	dXSTARG;
#line 4183 "SSLeay.xs"
  RETVAL = SSL_SESSION_get_ex_data(ses,0);
#line 11494 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_session_reused); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_session_reused)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;
#line 4191 "SSLeay.xs"
  RETVAL = SSL_ctrl(ssl,SSL_CTRL_GET_SESSION_REUSED,0,NULL);
#line 11517 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SESSION_set_app_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_set_app_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, a");
    {
	SSL_SESSION *	s = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
	void *	a = INT2PTR(void *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;
#line 4200 "SSLeay.xs"
  RETVAL = SSL_SESSION_set_ex_data(s,0,(char *)a);
#line 11541 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_app_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_app_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, arg");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	void *	arg = INT2PTR(void *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;
#line 4209 "SSLeay.xs"
  RETVAL = SSL_set_ex_data(s,0,(char *)arg);
#line 11565 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_mode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_mode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, op");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	long	op = (long)SvIV(ST(1));
	long	RETVAL;
	dXSTARG;
#line 4218 "SSLeay.xs"
  RETVAL = SSL_ctrl(ssl,SSL_CTRL_MODE,op,NULL);
#line 11589 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_pref_cipher); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_pref_cipher)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, n");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	const char *	n = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;
#line 4227 "SSLeay.xs"
  RETVAL = SSL_set_cipher_list(s,n);
#line 11613 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_tmp_dh); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_tmp_dh)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, dh");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	DH *	dh = INT2PTR(DH *,SvIV(ST(1)));
	long	RETVAL;
	dXSTARG;

	RETVAL = SSL_set_tmp_dh(ssl, dh);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set_tmp_rsa); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_tmp_rsa)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ssl, rsa");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	char *	rsa = (char *)SvPV_nolen(ST(1));
	long	RETVAL;
	dXSTARG;
#line 4241 "SSLeay.xs"
  RETVAL = SSL_ctrl(ssl,SSL_CTRL_SET_TMP_RSA,0,(char *)rsa);
#line 11660 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_RSA_generate_key); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RSA_generate_key)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "bits, e, perl_cb=&PL_sv_undef, perl_data=&PL_sv_undef");
    {
	int	bits = (int)SvIV(ST(0));
	unsigned long	e = (unsigned long)SvUV(ST(1));
	SV*	perl_cb;
	SV*	perl_data;
#line 4252 "SSLeay.xs"
        simple_cb_data_t* cb = NULL;
#line 11684 "SSLeay.c"
	RSA *	RETVAL;
	dXSTARG;

	if (items < 3)
	    perl_cb = &PL_sv_undef;
	else {
	    perl_cb = ST(2);
	}

	if (items < 4)
	    perl_data = &PL_sv_undef;
	else {
	    perl_data = ST(3);
	}
#line 4254 "SSLeay.xs"
        cb = simple_cb_data_new(perl_cb, perl_data);
        RETVAL = RSA_generate_key(bits, e, ssleay_RSA_generate_key_cb_invoke, cb);
        simple_cb_data_free(cb);
#line 11703 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_RSA_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_RSA_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "r");
    {
	RSA *	r = INT2PTR(RSA *,SvIV(ST(0)));

	RSA_free(r);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_X509_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	X509 *	RETVAL;
	dXSTARG;

	RETVAL = X509_new();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "a");
    {
	X509 *	a = INT2PTR(X509 *,SvIV(ST(0)));

	X509_free(a);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_d2i_X509_CRL_bio); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_d2i_X509_CRL_bio)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "bp, unused=NULL");
    {
	X509_CRL *	RETVAL;
	dXSTARG;
	BIO *	bp = INT2PTR(BIO *,SvIV(ST(0)));
	void *	unused;

	if (items < 2)
	    unused = NULL;
	else {
	    unused = INT2PTR(void *,SvIV(ST(1)));
	}

	RETVAL = d2i_X509_CRL_bio(bp, unused);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_d2i_X509_REQ_bio); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_d2i_X509_REQ_bio)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "bp, unused=NULL");
    {
	X509_REQ *	RETVAL;
	dXSTARG;
	BIO *	bp = INT2PTR(BIO *,SvIV(ST(0)));
	void *	unused;

	if (items < 2)
	    unused = NULL;
	else {
	    unused = INT2PTR(void *,SvIV(ST(1)));
	}

	RETVAL = d2i_X509_REQ_bio(bp, unused);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_d2i_X509_bio); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_d2i_X509_bio)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "bp, unused=NULL");
    {
	X509 *	RETVAL;
	dXSTARG;
	BIO *	bp = INT2PTR(BIO *,SvIV(ST(0)));
	void *	unused;

	if (items < 2)
	    unused = NULL;
	else {
	    unused = INT2PTR(void *,SvIV(ST(1)));
	}

	RETVAL = d2i_X509_bio(bp, unused);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_PEM_read_bio_DHparams); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_PEM_read_bio_DHparams)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 4)
       croak_xs_usage(cv,  "bio, x=NULL, cb=NULL, u=NULL");
    {
	BIO *	bio = INT2PTR(BIO *,SvIV(ST(0)));
	void *	x;
	pem_password_cb *	cb;
	void *	u;
	DH *	RETVAL;
	dXSTARG;

	if (items < 2)
	    x = NULL;
	else {
	    x = INT2PTR(void *,SvIV(ST(1)));
	}

	if (items < 3)
	    cb = NULL;
	else {
	    cb = INT2PTR(pem_password_cb *,SvIV(ST(2)));
	}

	if (items < 4)
	    u = NULL;
	else {
	    u = INT2PTR(void *,SvIV(ST(3)));
	}

	RETVAL = PEM_read_bio_DHparams(bio, x, cb, u);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_PEM_read_bio_X509_CRL); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_PEM_read_bio_X509_CRL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 4)
       croak_xs_usage(cv,  "bio, x=NULL, cb=NULL, u=NULL");
    {
	BIO *	bio = INT2PTR(BIO *,SvIV(ST(0)));
	void *	x;
	pem_password_cb *	cb;
	void *	u;
	X509_CRL *	RETVAL;
	dXSTARG;

	if (items < 2)
	    x = NULL;
	else {
	    x = INT2PTR(void *,SvIV(ST(1)));
	}

	if (items < 3)
	    cb = NULL;
	else {
	    cb = INT2PTR(pem_password_cb *,SvIV(ST(2)));
	}

	if (items < 4)
	    u = NULL;
	else {
	    u = INT2PTR(void *,SvIV(ST(3)));
	}

	RETVAL = PEM_read_bio_X509_CRL(bio, x, cb, u);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_PEM_read_bio_X509); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_PEM_read_bio_X509)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 4)
       croak_xs_usage(cv,  "bio, x=NULL, cb=NULL, u=NULL");
    {
	X509 *	RETVAL;
	dXSTARG;
	BIO *	bio = INT2PTR(BIO *,SvIV(ST(0)));
	void *	x;
	void *	cb;
	void *	u;

	if (items < 2)
	    x = NULL;
	else {
	    x = INT2PTR(void *,SvIV(ST(1)));
	}

	if (items < 3)
	    cb = NULL;
	else {
	    cb = INT2PTR(void *,SvIV(ST(2)));
	}

	if (items < 4)
	    u = NULL;
	else {
	    u = INT2PTR(void *,SvIV(ST(3)));
	}

	RETVAL = PEM_read_bio_X509(bio, x, cb, u);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_PEM_read_bio_X509_REQ); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_PEM_read_bio_X509_REQ)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 4)
       croak_xs_usage(cv,  "bio, x=NULL, cb=NULL, u=NULL");
    {
	X509_REQ *	RETVAL;
	dXSTARG;
	BIO *	bio = INT2PTR(BIO *,SvIV(ST(0)));
	void *	x;
	pem_password_cb *	cb;
	void *	u;

	if (items < 2)
	    x = NULL;
	else {
	    x = INT2PTR(void *,SvIV(ST(1)));
	}

	if (items < 3)
	    cb = NULL;
	else {
	    cb = INT2PTR(pem_password_cb *,SvIV(ST(2)));
	}

	if (items < 4)
	    u = NULL;
	else {
	    u = INT2PTR(void *,SvIV(ST(3)));
	}

	RETVAL = PEM_read_bio_X509_REQ(bio, x, cb, u);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_PEM_read_bio_PrivateKey); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_PEM_read_bio_PrivateKey)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "bio, perl_cb=&PL_sv_undef, perl_data=&PL_sv_undef");
    {
	BIO *	bio = INT2PTR(BIO *,SvIV(ST(0)));
	SV*	perl_cb;
	SV*	perl_data;
#line 4306 "SSLeay.xs"
        simple_cb_data_t* cb = NULL;
#line 12044 "SSLeay.c"
	EVP_PKEY *	RETVAL;
	dXSTARG;

	if (items < 2)
	    perl_cb = &PL_sv_undef;
	else {
	    perl_cb = ST(1);
	}

	if (items < 3)
	    perl_data = &PL_sv_undef;
	else {
	    perl_data = ST(2);
	}
#line 4308 "SSLeay.xs"
        RETVAL = 0;
        if (SvOK(perl_cb)) {
            /* setup our callback */
            cb = simple_cb_data_new(perl_cb, perl_data);
            RETVAL = PEM_read_bio_PrivateKey(bio, NULL, pem_password_cb_invoke, (void*)cb);
            simple_cb_data_free(cb);
        }
        else if (!SvOK(perl_cb) && SvOK(perl_data) && SvPOK(perl_data)) {
            /* use perl_data as the password */
            RETVAL = PEM_read_bio_PrivateKey(bio, NULL, NULL, SvPVX(perl_data));
        }
        else if (!SvOK(perl_cb) && !SvOK(perl_data)) {
            /* will trigger default password callback */
            RETVAL = PEM_read_bio_PrivateKey(bio, NULL, NULL, NULL);
        }
#line 12075 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_DH_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_DH_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dh");
    {
	DH *	dh = INT2PTR(DH *,SvIV(ST(0)));

	DH_free(dh);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_total_renegotiations); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_total_renegotiations)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	long	RETVAL;
	dXSTARG;
#line 4334 "SSLeay.xs"
  RETVAL = SSL_ctrl(ssl,SSL_CTRL_GET_TOTAL_RENEGOTIATIONS,0,NULL);
#line 12117 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SESSION_get_master_key); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_get_master_key)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL_SESSION *	s = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
#line 4342 "SSLeay.xs"
     ST(0) = sv_newmortal();   /* Undefined to start with */
     sv_setpvn(ST(0), (const char*)s->master_key, s->master_key_length);
#line 12139 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_SESSION_set_master_key); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_SESSION_set_master_key)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, key");
    {
	SSL_SESSION *	s = INT2PTR(SSL_SESSION *,SvIV(ST(0)));
#line 4349 "SSLeay.xs"
     STRLEN len;
#line 12159 "SSLeay.c"
	char *	key = SvPV(ST(1), len);
#line 4353 "SSLeay.xs"
     memcpy(s->master_key, key, len);
     s->master_key_length = len;
#line 12164 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_get_client_random); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_client_random)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
#line 4360 "SSLeay.xs"
     ST(0) = sv_newmortal();   /* Undefined to start with */
     sv_setpvn(ST(0), (const char*)s->s3->client_random, SSL3_RANDOM_SIZE);
#line 12185 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_server_random); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_server_random)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
#line 4367 "SSLeay.xs"
     ST(0) = sv_newmortal();   /* Undefined to start with */
     sv_setpvn(ST(0), (const char*)s->s3->server_random, SSL3_RANDOM_SIZE);
#line 12206 "SSLeay.c"
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_get_keyblock_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_keyblock_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;
#line 4374 "SSLeay.xs"
     if (s == NULL ||
	 s->enc_read_ctx == NULL ||
	 s->enc_read_ctx->cipher == NULL ||
	 s->read_hash == NULL)
     {
	RETVAL = -1;
     }
     else
     {
	const EVP_CIPHER *c;
	const EVP_MD *h;
	c = s->enc_read_ctx->cipher;
#if OPENSSL_VERSION_NUMBER >= 0x00909000L
	h = EVP_MD_CTX_md(s->read_hash);
#else
	h = s->read_hash;
#endif

	RETVAL = 2 * (EVP_CIPHER_key_length(c) +
		    EVP_MD_size(h) +
		    EVP_CIPHER_iv_length(c));
     }
#line 12249 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if defined(SSL_F_SSL_SET_HELLO_EXTENSION)
#define XSubPPtmpAABN 1


XS(XS_Net__SSLeay_set_hello_extension); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_hello_extension)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "s, type, data");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	int	type = (int)SvIV(ST(1));
#line 4407 "SSLeay.xs"
     STRLEN len;
#line 12274 "SSLeay.c"
	char *	data = SvPV( ST(2), len);
	int	RETVAL;
	dXSTARG;
#line 4411 "SSLeay.xs"
     RETVAL = SSL_set_hello_extension(s, type, data, len);
#line 12280 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif
#if defined(SSL_F_SSL_SET_HELLO_EXTENSION) || defined(SSL_F_SSL_SET_SESSION_TICKET_EXT)
#define XSubPPtmpAABO 1


XS(XS_Net__SSLeay_set_session_secret_cb); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set_session_secret_cb)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "s, callback=&PL_sv_undef, data=&PL_sv_undef");
    {
	SSL *	s = INT2PTR(SSL *,SvIV(ST(0)));
	SV *	callback;
	SV *	data;

	if (items < 2)
	    callback = &PL_sv_undef;
	else {
	    callback = ST(1);
	}

	if (items < 3)
	    data = &PL_sv_undef;
	else {
	    data = ST(2);
	}
#line 4425 "SSLeay.xs"
        if (callback==NULL || !SvOK(callback)) {
            SSL_set_session_secret_cb(s, NULL, NULL);
            cb_data_advanced_put(s, "ssleay_session_secret_cb!!func", NULL);
            cb_data_advanced_put(s, "ssleay_session_secret_cb!!data", NULL);
        }
        else {
            cb_data_advanced_put(s, "ssleay_session_secret_cb!!func", newSVsv(callback));
            cb_data_advanced_put(s, "ssleay_session_secret_cb!!data", newSVsv(data));
            SSL_set_session_secret_cb(s, (int (*)(SSL *s, void *secret, int *secret_len,
                STACK_OF(SSL_CIPHER) *peer_ciphers,
                SSL_CIPHER **cipher, void *arg))&ssleay_session_secret_cb_invoke, s);
        }
#line 12330 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}

#endif
#if OPENSSL_VERSION_NUMBER < 0x0090700fL
#define REM11 "NOTE: before 0.9.7"
#define XSubPPtmpAABP 1


XS(XS_Net__SSLeay_EVP_add_digest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_add_digest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "digest");
    {
	int	RETVAL;
	dXSTARG;
	EVP_MD *	digest = INT2PTR(EVP_MD *,SvIV(ST(0)));

	RETVAL = EVP_add_digest(digest);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAABQ 1


XS(XS_Net__SSLeay_EVP_add_digest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_add_digest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "digest");
    {
	int	RETVAL;
	dXSTARG;
	const EVP_MD *	digest = INT2PTR(const EVP_MD *,SvIV(ST(0)));

	RETVAL = EVP_add_digest(digest);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif
#ifndef OPENSSL_NO_SHA
#define XSubPPtmpAABR 1


XS(XS_Net__SSLeay_EVP_sha1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_sha1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const EVP_MD *	RETVAL;
	dXSTARG;

	RETVAL = EVP_sha1();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#endif
#if !defined(OPENSSL_NO_SHA256) && OPENSSL_VERSION_NUMBER >= 0x0090800fL
#define XSubPPtmpAABS 1


XS(XS_Net__SSLeay_EVP_sha256); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_sha256)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const EVP_MD *	RETVAL;
	dXSTARG;

	RETVAL = EVP_sha256();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#endif
#if !defined(OPENSSL_NO_SHA512) && OPENSSL_VERSION_NUMBER >= 0x0090800fL
#define XSubPPtmpAABT 1


XS(XS_Net__SSLeay_EVP_sha512); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_sha512)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const EVP_MD *	RETVAL;
	dXSTARG;

	RETVAL = EVP_sha512();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_OpenSSL_add_all_digests); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OpenSSL_add_all_digests)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	OpenSSL_add_all_digests();
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_EVP_get_digestbyname); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_get_digestbyname)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	const EVP_MD *	RETVAL;
	dXSTARG;
	const char *	name = (const char *)SvPV_nolen(ST(0));

	RETVAL = EVP_get_digestbyname(name);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_EVP_MD_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_MD_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "md");
    {
	int	RETVAL;
	dXSTARG;
	const EVP_MD *	md = INT2PTR(const EVP_MD *,SvIV(ST(0)));

	RETVAL = EVP_MD_type(md);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_EVP_MD_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_MD_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "md");
    {
	int	RETVAL;
	dXSTARG;
	const EVP_MD *	md = INT2PTR(const EVP_MD *,SvIV(ST(0)));

	RETVAL = EVP_MD_size(md);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x1000000fL
#define XSubPPtmpAABU 1


XS(XS_Net__SSLeay_P_EVP_MD_list_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_EVP_MD_list_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 4479 "SSLeay.xs"
        AV * results;
#line 12565 "SSLeay.c"
#line 4481 "SSLeay.xs"
        results = (AV *)sv_2mortal((SV *)newAV());
        EVP_MD_do_all_sorted(handler_list_md_fn, results);
        RETVAL = newRV((SV *)results);
#line 12570 "SSLeay.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif
#if OPENSSL_VERSION_NUMBER >= 0x0090700fL
#define REM16 "NOTE: requires 0.9.7+"
#define XSubPPtmpAABV 1


XS(XS_Net__SSLeay_EVP_MD_CTX_md); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_MD_CTX_md)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	const EVP_MD *	RETVAL;
	dXSTARG;
	const EVP_MD_CTX *	ctx = INT2PTR(const EVP_MD_CTX *,SvIV(ST(0)));

	RETVAL = EVP_MD_CTX_md(ctx);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_EVP_MD_CTX_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_MD_CTX_create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	EVP_MD_CTX *	RETVAL;
	dXSTARG;

	RETVAL = EVP_MD_CTX_create();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_EVP_DigestInit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_DigestInit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, type");
    {
	int	RETVAL;
	dXSTARG;
	EVP_MD_CTX *	ctx = INT2PTR(EVP_MD_CTX *,SvIV(ST(0)));
	const EVP_MD *	type = INT2PTR(const EVP_MD *,SvIV(ST(1)));

	RETVAL = EVP_DigestInit(ctx, type);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_EVP_DigestInit_ex); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_DigestInit_ex)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "ctx, type, impl");
    {
	int	RETVAL;
	dXSTARG;
	EVP_MD_CTX *	ctx = INT2PTR(EVP_MD_CTX *,SvIV(ST(0)));
	const EVP_MD *	type = INT2PTR(const EVP_MD *,SvIV(ST(1)));
	ENGINE *	impl = INT2PTR(ENGINE *,SvIV(ST(2)));

	RETVAL = EVP_DigestInit_ex(ctx, type, impl);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_EVP_MD_CTX_destroy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_MD_CTX_destroy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	EVP_MD_CTX *	ctx = INT2PTR(EVP_MD_CTX *,SvIV(ST(0)));

	EVP_MD_CTX_destroy(ctx);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_EVP_DigestUpdate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_DigestUpdate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, data");
    {
#line 4505 "SSLeay.xs"
     STRLEN len;
#line 12705 "SSLeay.c"
	EVP_MD_CTX *	ctx = INT2PTR(EVP_MD_CTX *, SvIV(ST(0)));
	unsigned char *	data = (unsigned char *) SvPV(ST(1), len);
#line 4510 "SSLeay.xs"
     XSRETURN_IV(EVP_DigestUpdate(ctx,data,len));
#line 12710 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_EVP_DigestFinal); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_DigestFinal)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	EVP_MD_CTX *	ctx = INT2PTR(EVP_MD_CTX *,SvIV(ST(0)));
#line 4516 "SSLeay.xs"
     unsigned char md[EVP_MAX_MD_SIZE];
     unsigned int md_size;
#line 12731 "SSLeay.c"
#line 4519 "SSLeay.xs"
     if (EVP_DigestFinal(ctx,md,&md_size))
         XSRETURN_PVN((char *)md, md_size);
     else
         XSRETURN_UNDEF;
#line 12737 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_EVP_DigestFinal_ex); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_DigestFinal_ex)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	EVP_MD_CTX *	ctx = INT2PTR(EVP_MD_CTX *,SvIV(ST(0)));
#line 4528 "SSLeay.xs"
     unsigned char md[EVP_MAX_MD_SIZE];
     unsigned int md_size;
#line 12758 "SSLeay.c"
#line 4531 "SSLeay.xs"
     if (EVP_DigestFinal_ex(ctx,md,&md_size))
         XSRETURN_PVN((char *)md, md_size);
     else
         XSRETURN_UNDEF;
#line 12764 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_EVP_Digest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_Digest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 4539 "SSLeay.xs"
     STRLEN len;
     unsigned char md[EVP_MAX_MD_SIZE];
     unsigned int md_size;
#line 12784 "SSLeay.c"
	unsigned char *	data = (unsigned char *) SvPV(ST(0), len);
	EVP_MD *	type = INT2PTR(EVP_MD *, SvIV(ST(1)));
	ENGINE *	impl = (items>2 && SvOK(ST(2))) ? INT2PTR(ENGINE *, SvIV(ST(2))) : NULL;
#line 4547 "SSLeay.xs"
     if (EVP_Digest(data,len,md,&md_size,type,impl))
         XSRETURN_PVN((char *)md, md_size);
     else
         XSRETURN_UNDEF;
#line 12793 "SSLeay.c"
    }
    XSRETURN_EMPTY;
}

#endif

XS(XS_Net__SSLeay_EVP_get_cipherbyname); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_EVP_get_cipherbyname)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	const EVP_CIPHER *	RETVAL;
	dXSTARG;
	const char *	name = (const char *)SvPV_nolen(ST(0));

	RETVAL = EVP_get_cipherbyname(name);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_OpenSSL_add_all_algorithms); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OpenSSL_add_all_algorithms)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	OpenSSL_add_all_algorithms();
    }
    XSRETURN_EMPTY;
}

#if OPENSSL_VERSION_NUMBER >= 0x0090700fL
#define XSubPPtmpAABW 1


XS(XS_Net__SSLeay_OPENSSL_add_all_algorithms_noconf); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OPENSSL_add_all_algorithms_noconf)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	OPENSSL_add_all_algorithms_noconf();
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_OPENSSL_add_all_algorithms_conf); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OPENSSL_add_all_algorithms_conf)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	OPENSSL_add_all_algorithms_conf();
    }
    XSRETURN_EMPTY;
}

#endif
#if OPENSSL_VERSION_NUMBER >= 0x10000000L
#define XSubPPtmpAABX 1


XS(XS_Net__SSLeay_CTX_set1_param); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set1_param)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, vpm");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	X509_VERIFY_PARAM *	vpm = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_CTX_set1_param(ctx, vpm);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_set1_param); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_set1_param)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ctx, vpm");
    {
	SSL *	ctx = INT2PTR(SSL *,SvIV(ST(0)));
	X509_VERIFY_PARAM *	vpm = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = SSL_set1_param(ctx, vpm);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif
#if OPENSSL_VERSION_NUMBER >= 0x0090800fL
#define XSubPPtmpAABY 1


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	X509_VERIFY_PARAM *	RETVAL;
	dXSTARG;

	RETVAL = X509_VERIFY_PARAM_new();
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "param");
    {
	X509_VERIFY_PARAM *	param = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));

	X509_VERIFY_PARAM_free(param);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_inherit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_inherit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "to, from");
    {
	X509_VERIFY_PARAM *	to = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));
	X509_VERIFY_PARAM *	from = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_VERIFY_PARAM_inherit(to, from);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "to, from");
    {
	X509_VERIFY_PARAM *	to = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));
	X509_VERIFY_PARAM *	from = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_VERIFY_PARAM_set1(to, from);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set1_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set1_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "param, name");
    {
	X509_VERIFY_PARAM *	param = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));
	const char *	name = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_VERIFY_PARAM_set1_name(param, name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set_flags); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set_flags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "param, flags");
    {
	X509_VERIFY_PARAM *	param = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));
	unsigned long	flags = (unsigned long)SvUV(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_VERIFY_PARAM_set_flags(param, flags);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x0090801fL
#define REM13 "NOTE: requires 0.9.8a+"
#define XSubPPtmpAABZ 1


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_clear_flags); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_clear_flags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "param, flags");
    {
	X509_VERIFY_PARAM *	param = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));
	unsigned long	flags = (unsigned long)SvUV(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_VERIFY_PARAM_clear_flags(param, flags);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_get_flags); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_get_flags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "param");
    {
	X509_VERIFY_PARAM *	param = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));
	unsigned long	RETVAL;
	dXSTARG;

	RETVAL = X509_VERIFY_PARAM_get_flags(param);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set_purpose); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set_purpose)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "param, purpose");
    {
	X509_VERIFY_PARAM *	param = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));
	int	purpose = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_VERIFY_PARAM_set_purpose(param, purpose);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set_trust); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set_trust)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "param, trust");
    {
	X509_VERIFY_PARAM *	param = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));
	int	trust = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_VERIFY_PARAM_set_trust(param, trust);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set_depth); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set_depth)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "param, depth");
    {
	X509_VERIFY_PARAM *	param = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));
	int	depth = (int)SvIV(ST(1));

	X509_VERIFY_PARAM_set_depth(param, depth);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set_time); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set_time)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "param, t");
    {
	X509_VERIFY_PARAM *	param = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));
	time_t	t = (time_t)SvNV(ST(1));

	X509_VERIFY_PARAM_set_time(param, t);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_add0_policy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_add0_policy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "param, policy");
    {
	X509_VERIFY_PARAM *	param = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));
	ASN1_OBJECT *	policy = INT2PTR(ASN1_OBJECT *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_VERIFY_PARAM_add0_policy(param, policy);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set1_policies); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_set1_policies)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "param, policies");
    {
	X509_VERIFY_PARAM *	param = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));
	STACK_OF(ASN1_OBJECT) *	policies = INT2PTR(STACK_OF(ASN1_OBJECT) *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_VERIFY_PARAM_set1_policies(param, policies);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_get_depth); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_get_depth)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "param");
    {
	X509_VERIFY_PARAM *	param = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_VERIFY_PARAM_get_depth(param);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_add0_table); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_add0_table)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "param");
    {
	X509_VERIFY_PARAM *	param = INT2PTR(X509_VERIFY_PARAM *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_VERIFY_PARAM_add0_table(param);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_lookup); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_lookup)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	const char *	name = (const char *)SvPV_nolen(ST(0));
	const X509_VERIFY_PARAM *	RETVAL;
	dXSTARG;

	RETVAL = X509_VERIFY_PARAM_lookup(name);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_VERIFY_PARAM_table_cleanup); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_VERIFY_PARAM_table_cleanup)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	X509_VERIFY_PARAM_table_cleanup();
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_X509_policy_tree_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_policy_tree_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "tree");
    {
	X509_POLICY_TREE *	tree = INT2PTR(X509_POLICY_TREE *,SvIV(ST(0)));

	X509_policy_tree_free(tree);
    }
    XSRETURN_EMPTY;
}


XS(XS_Net__SSLeay_X509_policy_tree_level_count); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_policy_tree_level_count)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "tree");
    {
	X509_POLICY_TREE *	tree = INT2PTR(X509_POLICY_TREE *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_policy_tree_level_count(tree);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_policy_tree_get0_level); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_policy_tree_get0_level)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "tree, i");
    {
	X509_POLICY_TREE *	tree = INT2PTR(X509_POLICY_TREE *,SvIV(ST(0)));
	int	i = (int)SvIV(ST(1));
	X509_POLICY_LEVEL *	RETVAL;
	dXSTARG;

	RETVAL = X509_policy_tree_get0_level(tree, i);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_policy_tree_get0_policies); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_policy_tree_get0_policies)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "tree");
    {
	X509_POLICY_TREE *	tree = INT2PTR(X509_POLICY_TREE *,SvIV(ST(0)));
	STACK_OF(X509_POLICY_NODE) *	RETVAL;
	dXSTARG;

	RETVAL = X509_policy_tree_get0_policies(tree);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_policy_tree_get0_user_policies); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_policy_tree_get0_user_policies)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "tree");
    {
	X509_POLICY_TREE *	tree = INT2PTR(X509_POLICY_TREE *,SvIV(ST(0)));
	STACK_OF(X509_POLICY_NODE) *	RETVAL;
	dXSTARG;

	RETVAL = X509_policy_tree_get0_user_policies(tree);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_policy_level_node_count); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_policy_level_node_count)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "level");
    {
	X509_POLICY_LEVEL *	level = INT2PTR(X509_POLICY_LEVEL *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = X509_policy_level_node_count(level);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_policy_level_get0_node); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_policy_level_get0_node)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "level, i");
    {
	X509_POLICY_LEVEL *	level = INT2PTR(X509_POLICY_LEVEL *,SvIV(ST(0)));
	int	i = (int)SvIV(ST(1));
	X509_POLICY_NODE *	RETVAL;
	dXSTARG;

	RETVAL = X509_policy_level_get0_node(level, i);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_policy_node_get0_policy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_policy_node_get0_policy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "node");
    {
	const X509_POLICY_NODE *	node = INT2PTR(const X509_POLICY_NODE *,SvIV(ST(0)));
	const ASN1_OBJECT *	RETVAL;
	dXSTARG;

	RETVAL = X509_policy_node_get0_policy(node);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_policy_node_get0_qualifiers); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_policy_node_get0_qualifiers)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "node");
    {
	X509_POLICY_NODE *	node = INT2PTR(X509_POLICY_NODE *,SvIV(ST(0)));
	STACK_OF(POLICYQUALINFO) *	RETVAL;
	dXSTARG;

	RETVAL = X509_policy_node_get0_qualifiers(node);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_policy_node_get0_parent); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_policy_node_get0_parent)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "node");
    {
	const X509_POLICY_NODE *	node = INT2PTR(const X509_POLICY_NODE *,SvIV(ST(0)));
	const X509_POLICY_NODE *	RETVAL;
	dXSTARG;

	RETVAL = X509_policy_node_get0_parent(node);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_OBJ_dup); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OBJ_dup)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	ASN1_OBJECT *	o = INT2PTR(ASN1_OBJECT *,SvIV(ST(0)));
	ASN1_OBJECT *	RETVAL;
	dXSTARG;

	RETVAL = OBJ_dup(o);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_OBJ_nid2obj); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OBJ_nid2obj)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "n");
    {
	int	n = (int)SvIV(ST(0));
	ASN1_OBJECT *	RETVAL;
	dXSTARG;

	RETVAL = OBJ_nid2obj(n);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_OBJ_nid2ln); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OBJ_nid2ln)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "n");
    {
	int	n = (int)SvIV(ST(0));
	const char *	RETVAL;
	dXSTARG;

	RETVAL = OBJ_nid2ln(n);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_OBJ_nid2sn); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OBJ_nid2sn)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "n");
    {
	int	n = (int)SvIV(ST(0));
	const char *	RETVAL;
	dXSTARG;

	RETVAL = OBJ_nid2sn(n);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_OBJ_obj2nid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OBJ_obj2nid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	ASN1_OBJECT *	o = INT2PTR(ASN1_OBJECT *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;

	RETVAL = OBJ_obj2nid(o);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_OBJ_txt2obj); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OBJ_txt2obj)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "s, no_name=0");
    {
	const char *	s = (const char *)SvPV_nolen(ST(0));
	int	no_name;
	ASN1_OBJECT *	RETVAL;
	dXSTARG;

	if (items < 2)
	    no_name = 0;
	else {
	    no_name = (int)SvIV(ST(1));
	}

	RETVAL = OBJ_txt2obj(s, no_name);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_OBJ_obj2txt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OBJ_obj2txt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "a, no_name=0");
    {
	ASN1_OBJECT *	a = INT2PTR(ASN1_OBJECT *,SvIV(ST(0)));
	int	no_name;
#line 4746 "SSLeay.xs"
    char buf[100]; /* openssl doc: a buffer length of 80 should be more than enough to handle any OID encountered in practice */
    int  len;
#line 13706 "SSLeay.c"

	if (items < 2)
	    no_name = 0;
	else {
	    no_name = (int)SvIV(ST(1));
	}
#line 4749 "SSLeay.xs"
    len = OBJ_obj2txt(buf, sizeof(buf), a, no_name);
    ST(0) = sv_newmortal();
    sv_setpvn(ST(0), buf, len);
#line 13717 "SSLeay.c"
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER < 0x0090700fL
#define REM14 "NOTE: before 0.9.7"
#define XSubPPtmpAACA 1


XS(XS_Net__SSLeay_OBJ_txt2nid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OBJ_txt2nid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	char *	s = (char *)SvPV_nolen(ST(0));
	int	RETVAL;
	dXSTARG;

	RETVAL = OBJ_txt2nid(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAACB 1


XS(XS_Net__SSLeay_OBJ_txt2nid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OBJ_txt2nid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	const char *	s = (const char *)SvPV_nolen(ST(0));
	int	RETVAL;
	dXSTARG;

	RETVAL = OBJ_txt2nid(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_Net__SSLeay_OBJ_ln2nid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OBJ_ln2nid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	const char *	s = (const char *)SvPV_nolen(ST(0));
	int	RETVAL;
	dXSTARG;

	RETVAL = OBJ_ln2nid(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_OBJ_sn2nid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OBJ_sn2nid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	const char *	s = (const char *)SvPV_nolen(ST(0));
	int	RETVAL;
	dXSTARG;

	RETVAL = OBJ_sn2nid(s);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_OBJ_cmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_OBJ_cmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "a, b");
    {
	ASN1_OBJECT *	a = INT2PTR(ASN1_OBJECT *,SvIV(ST(0)));
	ASN1_OBJECT *	b = INT2PTR(ASN1_OBJECT *,SvIV(ST(1)));
	int	RETVAL;
	dXSTARG;

	RETVAL = OBJ_cmp(a, b);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x0090700fL
#define XSubPPtmpAACC 1


XS(XS_Net__SSLeay_X509_pubkey_digest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_pubkey_digest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "data, type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const X509 *	data = INT2PTR(const X509 *,SvIV(ST(0)));
	const EVP_MD *	type = INT2PTR(const EVP_MD *,SvIV(ST(1)));
#line 4788 "SSLeay.xs"
        unsigned char md[EVP_MAX_MD_SIZE];
        unsigned int md_size;
#line 13863 "SSLeay.c"
#line 4791 "SSLeay.xs"
        if (X509_pubkey_digest(data,type,md,&md_size))
            XSRETURN_PVN((char *)md, md_size);
        else
            XSRETURN_UNDEF;
#line 13869 "SSLeay.c"
	PUTBACK;
	return;
    }
}

#endif

XS(XS_Net__SSLeay_X509_digest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_digest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "data, type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const X509 *	data = INT2PTR(const X509 *,SvIV(ST(0)));
	const EVP_MD *	type = INT2PTR(const EVP_MD *,SvIV(ST(1)));
#line 4803 "SSLeay.xs"
        unsigned char md[EVP_MAX_MD_SIZE];
        unsigned int md_size;
#line 13895 "SSLeay.c"
#line 4806 "SSLeay.xs"
        if (X509_digest(data,type,md,&md_size))
            XSRETURN_PVN((char *)md, md_size);
        XSRETURN_UNDEF;
#line 13900 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_X509_CRL_digest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_CRL_digest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "data, type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const X509_CRL *	data = INT2PTR(const X509_CRL *,SvIV(ST(0)));
	const EVP_MD *	type = INT2PTR(const EVP_MD *,SvIV(ST(1)));
#line 4815 "SSLeay.xs"
        unsigned char md[EVP_MAX_MD_SIZE];
        unsigned int md_size;
#line 13925 "SSLeay.c"
#line 4818 "SSLeay.xs"
        if (X509_CRL_digest(data,type,md,&md_size))
            XSRETURN_PVN((char *)md, md_size);
        XSRETURN_UNDEF;
#line 13930 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_X509_REQ_digest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_REQ_digest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "data, type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const X509_REQ *	data = INT2PTR(const X509_REQ *,SvIV(ST(0)));
	const EVP_MD *	type = INT2PTR(const EVP_MD *,SvIV(ST(1)));
#line 4827 "SSLeay.xs"
        unsigned char md[EVP_MAX_MD_SIZE];
        unsigned int md_size;
#line 13955 "SSLeay.c"
#line 4830 "SSLeay.xs"
        if (X509_REQ_digest(data,type,md,&md_size))
            XSRETURN_PVN((char *)md, md_size);
        XSRETURN_UNDEF;
#line 13960 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_X509_NAME_digest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_NAME_digest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "data, type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const X509_NAME *	data = INT2PTR(const X509_NAME *,SvIV(ST(0)));
	const EVP_MD *	type = INT2PTR(const EVP_MD *,SvIV(ST(1)));
#line 4839 "SSLeay.xs"
        unsigned char md[EVP_MAX_MD_SIZE];
        unsigned int md_size;
#line 13985 "SSLeay.c"
#line 4842 "SSLeay.xs"
        if (X509_NAME_digest(data,type,md,&md_size))
            XSRETURN_PVN((char *)md, md_size);
        XSRETURN_UNDEF;
#line 13990 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_X509_subject_name_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_subject_name_hash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	unsigned long	RETVAL;
	dXSTARG;
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));

	RETVAL = X509_subject_name_hash(x);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_issuer_name_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_issuer_name_hash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "a");
    {
	unsigned long	RETVAL;
	dXSTARG;
	X509 *	a = INT2PTR(X509 *,SvIV(ST(0)));

	RETVAL = X509_issuer_name_hash(a);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_X509_issuer_and_serial_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_X509_issuer_and_serial_hash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "a");
    {
	unsigned long	RETVAL;
	dXSTARG;
	X509 *	a = INT2PTR(X509 *,SvIV(ST(0)));

	RETVAL = X509_issuer_and_serial_hash(a);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_P_X509_get_signature_alg); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_X509_get_signature_alg)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));
	ASN1_OBJECT *	RETVAL;
	dXSTARG;
#line 4859 "SSLeay.xs"
        RETVAL = (x->cert_info->signature->algorithm);
#line 14079 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_P_X509_get_pubkey_alg); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_X509_get_pubkey_alg)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "x");
    {
	X509 *	x = INT2PTR(X509 *,SvIV(ST(0)));
	ASN1_OBJECT *	RETVAL;
	dXSTARG;
#line 4867 "SSLeay.xs"
        RETVAL = (x->cert_info->key->algor->algorithm);
#line 14102 "SSLeay.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x10001000L && !defined(OPENSSL_NO_NEXTPROTONEG)
#define XSubPPtmpAACD 1


XS(XS_Net__SSLeay_CTX_set_next_protos_advertised_cb); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_next_protos_advertised_cb)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "ctx, callback, data=&PL_sv_undef");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	SV *	callback = ST(1);
	SV *	data;
	int	RETVAL;
	dXSTARG;

	if (items < 3)
	    data = &PL_sv_undef;
	else {
	    data = ST(2);
	}
#line 4879 "SSLeay.xs"
        RETVAL = 1;
        if (callback==NULL || !SvOK(callback)) {
            SSL_CTX_set_next_protos_advertised_cb(ctx, NULL, NULL);
            cb_data_advanced_put(ctx, "next_protos_advertised_cb!!func", NULL);
            cb_data_advanced_put(ctx, "next_protos_advertised_cb!!data", NULL);
            PR1("SSL_CTX_set_next_protos_advertised_cb - undef\n");
        }
        else if (SvROK(callback) && (SvTYPE(SvRV(callback)) == SVt_PVAV)) {
            /* callback param array ref like ['proto1','proto2'] */
            cb_data_advanced_put(ctx, "next_protos_advertised_cb!!func", NULL);
            cb_data_advanced_put(ctx, "next_protos_advertised_cb!!data", newSVsv(callback));
            SSL_CTX_set_next_protos_advertised_cb(ctx, next_protos_advertised_cb_invoke, ctx);
            PR2("SSL_CTX_set_next_protos_advertised_cb - simple ctx=%p\n",ctx);
        }
        else if (SvROK(callback) && (SvTYPE(SvRV(callback)) == SVt_PVCV)) {
            cb_data_advanced_put(ctx, "next_protos_advertised_cb!!func", newSVsv(callback));
            cb_data_advanced_put(ctx, "next_protos_advertised_cb!!data", newSVsv(data));
            SSL_CTX_set_next_protos_advertised_cb(ctx, next_protos_advertised_cb_invoke, ctx);
            PR2("SSL_CTX_set_next_protos_advertised_cb - advanced ctx=%p\n",ctx);
        }
        else {
            RETVAL = 0;
        }
#line 14158 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_CTX_set_next_proto_select_cb); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_CTX_set_next_proto_select_cb)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "ctx, callback, data=&PL_sv_undef");
    {
	SSL_CTX *	ctx = INT2PTR(SSL_CTX *,SvIV(ST(0)));
	SV *	callback = ST(1);
	SV *	data;
	int	RETVAL;
	dXSTARG;

	if (items < 3)
	    data = &PL_sv_undef;
	else {
	    data = ST(2);
	}
#line 4911 "SSLeay.xs"
        RETVAL = 1;
        if (callback==NULL || !SvOK(callback)) {
            SSL_CTX_set_next_proto_select_cb(ctx, NULL, NULL);
            cb_data_advanced_put(ctx, "next_proto_select_cb!!func", NULL);
            cb_data_advanced_put(ctx, "next_proto_select_cb!!data", NULL);
            PR1("SSL_CTX_set_next_proto_select_cb - undef\n");
        }
        else if (SvROK(callback) && (SvTYPE(SvRV(callback)) == SVt_PVAV)) {
            /* callback param array ref like ['proto1','proto2'] */
            cb_data_advanced_put(ctx, "next_proto_select_cb!!func", NULL);
            cb_data_advanced_put(ctx, "next_proto_select_cb!!data", newSVsv(callback));
            SSL_CTX_set_next_proto_select_cb(ctx, next_proto_select_cb_invoke, ctx);
            PR2("SSL_CTX_set_next_proto_select_cb - simple ctx=%p\n",ctx);
        }
        else if (SvROK(callback) && (SvTYPE(SvRV(callback)) == SVt_PVCV)) {
            cb_data_advanced_put(ctx, "next_proto_select_cb!!func", newSVsv(callback));
            cb_data_advanced_put(ctx, "next_proto_select_cb!!data", newSVsv(data));
            SSL_CTX_set_next_proto_select_cb(ctx, next_proto_select_cb_invoke, ctx);
            PR2("SSL_CTX_set_next_proto_select_cb - advanced ctx=%p\n",ctx);
        }
        else {
            RETVAL = 0;
        }
#line 14211 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Net__SSLeay_P_next_proto_negotiated); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_next_proto_negotiated)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const SSL *	s = INT2PTR(const SSL *,SvIV(ST(0)));
#line 4941 "SSLeay.xs"
        const unsigned char *data;
        unsigned int len;
#line 14235 "SSLeay.c"
#line 4944 "SSLeay.xs"
        SSL_get0_next_proto_negotiated(s, &data, &len);
        XPUSHs(sv_2mortal(newSVpv((char *)data, len)));
#line 14239 "SSLeay.c"
	PUTBACK;
	return;
    }
}


XS(XS_Net__SSLeay_P_next_proto_last_status); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_P_next_proto_last_status)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const SSL *	s = INT2PTR(const SSL *,SvIV(ST(0)));
#line 4951 "SSLeay.xs"
        XPUSHs(sv_2mortal(newSVsv(cb_data_advanced_get((void*)s, "next_proto_select_cb!!last_status"))));
#line 14262 "SSLeay.c"
	PUTBACK;
	return;
    }
}

#endif
#if OPENSSL_VERSION_NUMBER >= 0x10001000L
#define XSubPPtmpAACE 1


XS(XS_Net__SSLeay_export_keying_material); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_export_keying_material)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "ssl, outlen, label, p");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SSL *	ssl = INT2PTR(SSL *,SvIV(ST(0)));
	int	outlen = (int)SvIV(ST(1));
#line 4962 "SSLeay.xs"
        char *  out;
        STRLEN labellen;
        STRLEN plen;
	int ret;
#line 14293 "SSLeay.c"
	char *	label = SvPV( ST(2), labellen);
	char *	p = SvPV( ST(3), plen);
#line 4970 "SSLeay.xs"
	New(0, out, outlen, char);
        ret = SSL_export_keying_material(ssl, out, outlen, label, labellen, p, plen, plen ? 1 : 0);
        PUSHs(sv_2mortal(ret>=0 ? newSVpvn(out, outlen) : newSV(0)));
        EXTEND(SP, 1);
	Safefree(out);
#line 14302 "SSLeay.c"
	PUTBACK;
	return;
    }
}

#endif
#if OPENSSL_VERSION_NUMBER >= 0x10002000L && !defined(OPENSSL_NO_DANE)
#define XSubPPtmpAACF 1


XS(XS_Net__SSLeay_get_tlsa_record_byname); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SSLeay_get_tlsa_record_byname)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "name, port, type");
    {
	char *	name = (char *)SvPV_nolen(ST(0));
	int	port = (int)SvIV(ST(1));
	int	type = (int)SvIV(ST(2));

	SSL_get_tlsa_record_byname(name, port, type);
    }
    XSRETURN_EMPTY;
}

#endif
#define REM_EOF "/* EOF - SSLeay.xs */"
#ifdef __cplusplus
extern "C"
#endif
XS(boot_Net__SSLeay); /* prototype to pass -Wmissing-prototypes */
XS(boot_Net__SSLeay)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK ;

    {
        CV * cv ;

        (void)newXSproto_portable("Net::SSLeay::CLONE", XS_Net__SSLeay_CLONE, file, ";@");
        (void)newXSproto_portable("Net::SSLeay::constant", XS_Net__SSLeay_constant, file, "$");
        (void)newXSproto_portable("Net::SSLeay::hello", XS_Net__SSLeay_hello, file, "");
        (void)newXSproto_portable("Net::SSLeay::SSLeay", XS_Net__SSLeay_SSLeay, file, "");
        (void)newXSproto_portable("Net::SSLeay::SSLeay_version", XS_Net__SSLeay_SSLeay_version, file, ";$");
        (void)newXSproto_portable("Net::SSLeay::CTX_new", XS_Net__SSLeay_CTX_new, file, "");
#if XSubPPtmpAAAA
        (void)newXSproto_portable("Net::SSLeay::CTX_v2_new", XS_Net__SSLeay_CTX_v2_new, file, "");
#endif
        (void)newXSproto_portable("Net::SSLeay::CTX_v3_new", XS_Net__SSLeay_CTX_v3_new, file, "");
        (void)newXSproto_portable("Net::SSLeay::CTX_v23_new", XS_Net__SSLeay_CTX_v23_new, file, "");
        (void)newXSproto_portable("Net::SSLeay::CTX_tlsv1_new", XS_Net__SSLeay_CTX_tlsv1_new, file, "");
#if XSubPPtmpAAAB
        (void)newXSproto_portable("Net::SSLeay::CTX_tlsv1_1_new", XS_Net__SSLeay_CTX_tlsv1_1_new, file, "");
#endif
#if XSubPPtmpAAAC
        (void)newXSproto_portable("Net::SSLeay::CTX_tlsv1_2_new", XS_Net__SSLeay_CTX_tlsv1_2_new, file, "");
#endif
        (void)newXSproto_portable("Net::SSLeay::CTX_new_with_method", XS_Net__SSLeay_CTX_new_with_method, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_free", XS_Net__SSLeay_CTX_free, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_add_session", XS_Net__SSLeay_CTX_add_session, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_remove_session", XS_Net__SSLeay_CTX_remove_session, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_flush_sessions", XS_Net__SSLeay_CTX_flush_sessions, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_default_verify_paths", XS_Net__SSLeay_CTX_set_default_verify_paths, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_load_verify_locations", XS_Net__SSLeay_CTX_load_verify_locations, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_verify", XS_Net__SSLeay_CTX_set_verify, file, "$$;$");
        (void)newXSproto_portable("Net::SSLeay::get_error", XS_Net__SSLeay_get_error, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::new", XS_Net__SSLeay_new, file, "$");
        (void)newXSproto_portable("Net::SSLeay::free", XS_Net__SSLeay_free, file, "$");
#if XSubPPtmpAAAD
        (void)newXSproto_portable("Net::SSLeay::debug", XS_Net__SSLeay_debug, file, "$");
#endif
        (void)newXSproto_portable("Net::SSLeay::accept", XS_Net__SSLeay_accept, file, "$");
        (void)newXSproto_portable("Net::SSLeay::clear", XS_Net__SSLeay_clear, file, "$");
        (void)newXSproto_portable("Net::SSLeay::connect", XS_Net__SSLeay_connect, file, "$");
#if XSubPPtmpAAAE
        (void)newXSproto_portable("Net::SSLeay::set_fd", XS_Net__SSLeay_set_fd, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_rfd", XS_Net__SSLeay_set_rfd, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_wfd", XS_Net__SSLeay_set_wfd, file, "$$");
#endif
#if XSubPPtmpAAAF
        (void)newXSproto_portable("Net::SSLeay::set_fd", XS_Net__SSLeay_set_fd, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_rfd", XS_Net__SSLeay_set_rfd, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_wfd", XS_Net__SSLeay_set_wfd, file, "$$");
#endif
        (void)newXSproto_portable("Net::SSLeay::get_fd", XS_Net__SSLeay_get_fd, file, "$");
        (void)newXSproto_portable("Net::SSLeay::read", XS_Net__SSLeay_read, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::peek", XS_Net__SSLeay_peek, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::write", XS_Net__SSLeay_write, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::write_partial", XS_Net__SSLeay_write_partial, file, "$$$$");
        (void)newXSproto_portable("Net::SSLeay::use_RSAPrivateKey", XS_Net__SSLeay_use_RSAPrivateKey, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::use_RSAPrivateKey_ASN1", XS_Net__SSLeay_use_RSAPrivateKey_ASN1, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::use_RSAPrivateKey_file", XS_Net__SSLeay_use_RSAPrivateKey_file, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_use_RSAPrivateKey_file", XS_Net__SSLeay_CTX_use_RSAPrivateKey_file, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::use_PrivateKey", XS_Net__SSLeay_use_PrivateKey, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::use_PrivateKey_ASN1", XS_Net__SSLeay_use_PrivateKey_ASN1, file, "$$$$");
        (void)newXSproto_portable("Net::SSLeay::use_PrivateKey_file", XS_Net__SSLeay_use_PrivateKey_file, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_use_PrivateKey_file", XS_Net__SSLeay_CTX_use_PrivateKey_file, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::use_certificate", XS_Net__SSLeay_use_certificate, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::use_certificate_ASN1", XS_Net__SSLeay_use_certificate_ASN1, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::use_certificate_file", XS_Net__SSLeay_use_certificate_file, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_use_certificate_file", XS_Net__SSLeay_CTX_use_certificate_file, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::state_string", XS_Net__SSLeay_state_string, file, "$");
        (void)newXSproto_portable("Net::SSLeay::rstate_string", XS_Net__SSLeay_rstate_string, file, "$");
        (void)newXSproto_portable("Net::SSLeay::state_string_long", XS_Net__SSLeay_state_string_long, file, "$");
        (void)newXSproto_portable("Net::SSLeay::rstate_string_long", XS_Net__SSLeay_rstate_string_long, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_time", XS_Net__SSLeay_get_time, file, "$");
        (void)newXSproto_portable("Net::SSLeay::set_time", XS_Net__SSLeay_set_time, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::get_timeout", XS_Net__SSLeay_get_timeout, file, "$");
        (void)newXSproto_portable("Net::SSLeay::set_timeout", XS_Net__SSLeay_set_timeout, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::copy_session_id", XS_Net__SSLeay_copy_session_id, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_read_ahead", XS_Net__SSLeay_set_read_ahead, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::get_read_ahead", XS_Net__SSLeay_get_read_ahead, file, "$");
        (void)newXSproto_portable("Net::SSLeay::pending", XS_Net__SSLeay_pending, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_cipher_list", XS_Net__SSLeay_CTX_set_cipher_list, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::get_cipher_list", XS_Net__SSLeay_get_cipher_list, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_cipher_list", XS_Net__SSLeay_set_cipher_list, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::get_cipher", XS_Net__SSLeay_get_cipher, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_shared_ciphers", XS_Net__SSLeay_get_shared_ciphers, file, "$;$$");
        (void)newXSproto_portable("Net::SSLeay::get_peer_certificate", XS_Net__SSLeay_get_peer_certificate, file, "$");
        (void)newXSproto_portable("Net::SSLeay::set_verify", XS_Net__SSLeay_set_verify, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::set_bio", XS_Net__SSLeay_set_bio, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::get_rbio", XS_Net__SSLeay_get_rbio, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_wbio", XS_Net__SSLeay_get_wbio, file, "$");
        (void)newXSproto_portable("Net::SSLeay::SESSION_new", XS_Net__SSLeay_SESSION_new, file, "");
        (void)newXSproto_portable("Net::SSLeay::SESSION_print", XS_Net__SSLeay_SESSION_print, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::SESSION_free", XS_Net__SSLeay_SESSION_free, file, "$");
        (void)newXSproto_portable("Net::SSLeay::i2d_SSL_SESSION", XS_Net__SSLeay_i2d_SSL_SESSION, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_session", XS_Net__SSLeay_set_session, file, "$$");
#if XSubPPtmpAAAG
        (void)newXSproto_portable("Net::SSLeay::d2i_SSL_SESSION", XS_Net__SSLeay_d2i_SSL_SESSION, file, "$$$");
#endif
#if XSubPPtmpAAAH
        (void)newXSproto_portable("Net::SSLeay::d2i_SSL_SESSION", XS_Net__SSLeay_d2i_SSL_SESSION, file, "$$$");
#endif
        cv = newXSproto_portable("Net::SSLeay::SSL_get0_session", XS_Net__SSLeay_get_session, file, "$");
        XSANY.any_i32 = 1 ;
        cv = newXSproto_portable("Net::SSLeay::get_session", XS_Net__SSLeay_get_session, file, "$");
        XSANY.any_i32 = 0 ;
        (void)newXSproto_portable("Net::SSLeay::get1_session", XS_Net__SSLeay_get1_session, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_certificate", XS_Net__SSLeay_get_certificate, file, "$");
#if XSubPPtmpAAAI
        (void)newXSproto_portable("Net::SSLeay::get_SSL_CTX", XS_Net__SSLeay_get_SSL_CTX, file, "$");
        (void)newXSproto_portable("Net::SSLeay::set_SSL_CTX", XS_Net__SSLeay_set_SSL_CTX, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::ctrl", XS_Net__SSLeay_ctrl, file, "$$$$");
#endif
        (void)newXSproto_portable("Net::SSLeay::CTX_ctrl", XS_Net__SSLeay_CTX_ctrl, file, "$$$$");
        (void)newXSproto_portable("Net::SSLeay::get_options", XS_Net__SSLeay_get_options, file, "$");
        (void)newXSproto_portable("Net::SSLeay::set_options", XS_Net__SSLeay_set_options, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_get_options", XS_Net__SSLeay_CTX_get_options, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_options", XS_Net__SSLeay_CTX_set_options, file, "$$");
#if XSubPPtmpAAAJ
        (void)newXSproto_portable("Net::SSLeay::CTX_sessions", XS_Net__SSLeay_CTX_sessions, file, "$");
#endif
#if XSubPPtmpAAAK
        (void)newXSproto_portable("Net::SSLeay::CTX_sessions", XS_Net__SSLeay_CTX_sessions, file, "$");
#endif
        (void)newXSproto_portable("Net::SSLeay::CTX_sess_number", XS_Net__SSLeay_CTX_sess_number, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_sess_connect", XS_Net__SSLeay_CTX_sess_connect, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_sess_connect_good", XS_Net__SSLeay_CTX_sess_connect_good, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_sess_connect_renegotiate", XS_Net__SSLeay_CTX_sess_connect_renegotiate, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_sess_accept", XS_Net__SSLeay_CTX_sess_accept, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_sess_accept_renegotiate", XS_Net__SSLeay_CTX_sess_accept_renegotiate, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_sess_accept_good", XS_Net__SSLeay_CTX_sess_accept_good, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_sess_hits", XS_Net__SSLeay_CTX_sess_hits, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_sess_cb_hits", XS_Net__SSLeay_CTX_sess_cb_hits, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_sess_misses", XS_Net__SSLeay_CTX_sess_misses, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_sess_timeouts", XS_Net__SSLeay_CTX_sess_timeouts, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_sess_cache_full", XS_Net__SSLeay_CTX_sess_cache_full, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_sess_get_cache_size", XS_Net__SSLeay_CTX_sess_get_cache_size, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_sess_set_cache_size", XS_Net__SSLeay_CTX_sess_set_cache_size, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::want", XS_Net__SSLeay_want, file, "$");
        (void)newXSproto_portable("Net::SSLeay::state", XS_Net__SSLeay_state, file, "$");
#if XSubPPtmpAAAL
        (void)newXSproto_portable("Net::SSLeay::set_tlsext_host_name", XS_Net__SSLeay_set_tlsext_host_name, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::get_servername", XS_Net__SSLeay_get_servername, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::get_servername_type", XS_Net__SSLeay_get_servername_type, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_tlsext_servername_callback", XS_Net__SSLeay_CTX_set_tlsext_servername_callback, file, "$;$$");
#endif
        (void)newXSproto_portable("Net::SSLeay::BIO_f_ssl", XS_Net__SSLeay_BIO_f_ssl, file, "");
        (void)newXSproto_portable("Net::SSLeay::BIO_s_mem", XS_Net__SSLeay_BIO_s_mem, file, "");
        (void)newXSproto_portable("Net::SSLeay::ERR_get_error", XS_Net__SSLeay_ERR_get_error, file, "");
        (void)newXSproto_portable("Net::SSLeay::ERR_peek_error", XS_Net__SSLeay_ERR_peek_error, file, "");
        (void)newXSproto_portable("Net::SSLeay::ERR_put_error", XS_Net__SSLeay_ERR_put_error, file, "$$$$$");
        (void)newXSproto_portable("Net::SSLeay::ERR_clear_error", XS_Net__SSLeay_ERR_clear_error, file, "");
        (void)newXSproto_portable("Net::SSLeay::ERR_error_string", XS_Net__SSLeay_ERR_error_string, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::load_error_strings", XS_Net__SSLeay_load_error_strings, file, "");
        (void)newXSproto_portable("Net::SSLeay::ERR_load_crypto_strings", XS_Net__SSLeay_ERR_load_crypto_strings, file, "");
        (void)newXSproto_portable("Net::SSLeay::FIPS_mode_set", XS_Net__SSLeay_FIPS_mode_set, file, "$");
        cv = newXSproto_portable("Net::SSLeay::add_ssl_algorithms", XS_Net__SSLeay_library_init, file, "");
        XSANY.any_i32 = 3 ;
        cv = newXSproto_portable("Net::SSLeay::library_init", XS_Net__SSLeay_library_init, file, "");
        XSANY.any_i32 = 0 ;
        cv = newXSproto_portable("Net::SSLeay::SSLeay_add_ssl_algorithms", XS_Net__SSLeay_library_init, file, "");
        XSANY.any_i32 = 1 ;
        cv = newXSproto_portable("Net::SSLeay::OpenSSL_add_ssl_algorithms", XS_Net__SSLeay_library_init, file, "");
        XSANY.any_i32 = 2 ;
#if XSubPPtmpAAAM
        (void)newXSproto_portable("Net::SSLeay::ENGINE_load_builtin_engines", XS_Net__SSLeay_ENGINE_load_builtin_engines, file, "");
        (void)newXSproto_portable("Net::SSLeay::ENGINE_register_all_complete", XS_Net__SSLeay_ENGINE_register_all_complete, file, "");
        (void)newXSproto_portable("Net::SSLeay::ENGINE_by_id", XS_Net__SSLeay_ENGINE_by_id, file, "$");
        (void)newXSproto_portable("Net::SSLeay::ENGINE_set_default", XS_Net__SSLeay_ENGINE_set_default, file, "$$");
#endif
        (void)newXSproto_portable("Net::SSLeay::ERR_load_SSL_strings", XS_Net__SSLeay_ERR_load_SSL_strings, file, "");
        (void)newXSproto_portable("Net::SSLeay::ERR_load_RAND_strings", XS_Net__SSLeay_ERR_load_RAND_strings, file, "");
        (void)newXSproto_portable("Net::SSLeay::RAND_bytes", XS_Net__SSLeay_RAND_bytes, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::RAND_pseudo_bytes", XS_Net__SSLeay_RAND_pseudo_bytes, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::RAND_add", XS_Net__SSLeay_RAND_add, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::RAND_poll", XS_Net__SSLeay_RAND_poll, file, "");
        (void)newXSproto_portable("Net::SSLeay::RAND_status", XS_Net__SSLeay_RAND_status, file, "");
        (void)newXSproto_portable("Net::SSLeay::RAND_egd_bytes", XS_Net__SSLeay_RAND_egd_bytes, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::RAND_file_name", XS_Net__SSLeay_RAND_file_name, file, "$");
        (void)newXSproto_portable("Net::SSLeay::RAND_seed", XS_Net__SSLeay_RAND_seed, file, "$");
        (void)newXSproto_portable("Net::SSLeay::RAND_cleanup", XS_Net__SSLeay_RAND_cleanup, file, "");
        (void)newXSproto_portable("Net::SSLeay::RAND_load_file", XS_Net__SSLeay_RAND_load_file, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::RAND_write_file", XS_Net__SSLeay_RAND_write_file, file, "$");
        (void)newXSproto_portable("Net::SSLeay::RAND_egd", XS_Net__SSLeay_RAND_egd, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_get_issuer_name", XS_Net__SSLeay_X509_get_issuer_name, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_get_subject_name", XS_Net__SSLeay_X509_get_subject_name, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_set_issuer_name", XS_Net__SSLeay_X509_set_issuer_name, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_set_subject_name", XS_Net__SSLeay_X509_set_subject_name, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_set_version", XS_Net__SSLeay_X509_set_version, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_set_pubkey", XS_Net__SSLeay_X509_set_pubkey, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_get_version", XS_Net__SSLeay_X509_get_version, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_get_pubkey", XS_Net__SSLeay_X509_get_pubkey, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_get_serialNumber", XS_Net__SSLeay_X509_get_serialNumber, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_set_serialNumber", XS_Net__SSLeay_X509_set_serialNumber, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_certificate_type", XS_Net__SSLeay_X509_certificate_type, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::X509_sign", XS_Net__SSLeay_X509_sign, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::X509_verify", XS_Net__SSLeay_X509_verify, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_NAME_new", XS_Net__SSLeay_X509_NAME_new, file, "");
        (void)newXSproto_portable("Net::SSLeay::X509_NAME_hash", XS_Net__SSLeay_X509_NAME_hash, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_NAME_oneline", XS_Net__SSLeay_X509_NAME_oneline, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_NAME_print_ex", XS_Net__SSLeay_X509_NAME_print_ex, file, "$;$$");
        (void)newXSproto_portable("Net::SSLeay::X509_NAME_get_text_by_NID", XS_Net__SSLeay_X509_NAME_get_text_by_NID, file, "$$");
#if XSubPPtmpAAAN
        (void)newXSproto_portable("Net::SSLeay::X509_NAME_add_entry_by_NID", XS_Net__SSLeay_X509_NAME_add_entry_by_NID, file, "$$$$;$$");
        (void)newXSproto_portable("Net::SSLeay::X509_NAME_add_entry_by_OBJ", XS_Net__SSLeay_X509_NAME_add_entry_by_OBJ, file, "$$$$;$$");
        (void)newXSproto_portable("Net::SSLeay::X509_NAME_add_entry_by_txt", XS_Net__SSLeay_X509_NAME_add_entry_by_txt, file, "$$$$;$$");
#endif
        (void)newXSproto_portable("Net::SSLeay::X509_NAME_cmp", XS_Net__SSLeay_X509_NAME_cmp, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_NAME_entry_count", XS_Net__SSLeay_X509_NAME_entry_count, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_NAME_get_entry", XS_Net__SSLeay_X509_NAME_get_entry, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_NAME_ENTRY_get_data", XS_Net__SSLeay_X509_NAME_ENTRY_get_data, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_NAME_ENTRY_get_object", XS_Net__SSLeay_X509_NAME_ENTRY_get_object, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_free", XS_Net__SSLeay_X509_CRL_free, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_new", XS_Net__SSLeay_X509_CRL_new, file, "");
#if XSubPPtmpAAAO
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_set_version", XS_Net__SSLeay_X509_CRL_set_version, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_set_issuer_name", XS_Net__SSLeay_X509_CRL_set_issuer_name, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_set_lastUpdate", XS_Net__SSLeay_X509_CRL_set_lastUpdate, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_set_nextUpdate", XS_Net__SSLeay_X509_CRL_set_nextUpdate, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_sort", XS_Net__SSLeay_X509_CRL_sort, file, "$");
#endif
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_get_version", XS_Net__SSLeay_X509_CRL_get_version, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_get_issuer", XS_Net__SSLeay_X509_CRL_get_issuer, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_get_lastUpdate", XS_Net__SSLeay_X509_CRL_get_lastUpdate, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_get_nextUpdate", XS_Net__SSLeay_X509_CRL_get_nextUpdate, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_verify", XS_Net__SSLeay_X509_CRL_verify, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_sign", XS_Net__SSLeay_X509_CRL_sign, file, "$$$");
#if XSubPPtmpAAAP
        (void)newXSproto_portable("Net::SSLeay::P_X509_CRL_set_serial", XS_Net__SSLeay_P_X509_CRL_set_serial, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::P_X509_CRL_get_serial", XS_Net__SSLeay_P_X509_CRL_get_serial, file, "$");
        (void)newXSproto_portable("Net::SSLeay::P_X509_CRL_add_revoked_serial_hex", XS_Net__SSLeay_P_X509_CRL_add_revoked_serial_hex, file, "$$$;$$");
#endif
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_new", XS_Net__SSLeay_X509_REQ_new, file, "");
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_free", XS_Net__SSLeay_X509_REQ_free, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_get_subject_name", XS_Net__SSLeay_X509_REQ_get_subject_name, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_set_subject_name", XS_Net__SSLeay_X509_REQ_set_subject_name, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_set_pubkey", XS_Net__SSLeay_X509_REQ_set_pubkey, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_get_pubkey", XS_Net__SSLeay_X509_REQ_get_pubkey, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_sign", XS_Net__SSLeay_X509_REQ_sign, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_verify", XS_Net__SSLeay_X509_REQ_verify, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_set_version", XS_Net__SSLeay_X509_REQ_set_version, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_get_version", XS_Net__SSLeay_X509_REQ_get_version, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_get_attr_count", XS_Net__SSLeay_X509_REQ_get_attr_count, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_get_attr_by_NID", XS_Net__SSLeay_X509_REQ_get_attr_by_NID, file, "$$;$");
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_get_attr_by_OBJ", XS_Net__SSLeay_X509_REQ_get_attr_by_OBJ, file, "$$;$");
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_add1_attr_by_NID", XS_Net__SSLeay_X509_REQ_add1_attr_by_NID, file, "$$$$");
#if XSubPPtmpAAAQ
        (void)newXSproto_portable("Net::SSLeay::P_X509_REQ_get_attr", XS_Net__SSLeay_P_X509_REQ_get_attr, file, "$$");
#endif
        (void)newXSproto_portable("Net::SSLeay::P_X509_REQ_add_extensions", XS_Net__SSLeay_P_X509_REQ_add_extensions, file, "$;@");
        (void)newXSproto_portable("Net::SSLeay::P_X509_add_extensions", XS_Net__SSLeay_P_X509_add_extensions, file, "$$;@");
        (void)newXSproto_portable("Net::SSLeay::P_X509_copy_extensions", XS_Net__SSLeay_P_X509_copy_extensions, file, "$$;$");
        (void)newXSproto_portable("Net::SSLeay::X509_STORE_CTX_get_current_cert", XS_Net__SSLeay_X509_STORE_CTX_get_current_cert, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_STORE_CTX_get_ex_data", XS_Net__SSLeay_X509_STORE_CTX_get_ex_data, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_get_fingerprint", XS_Net__SSLeay_X509_get_fingerprint, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_get_subjectAltNames", XS_Net__SSLeay_X509_get_subjectAltNames, file, "$");
#if XSubPPtmpAAAR
        (void)newXSproto_portable("Net::SSLeay::P_X509_get_crl_distribution_points", XS_Net__SSLeay_P_X509_get_crl_distribution_points, file, "$");
        (void)newXSproto_portable("Net::SSLeay::P_X509_get_ext_key_usage", XS_Net__SSLeay_P_X509_get_ext_key_usage, file, "$;$");
#endif
        (void)newXSproto_portable("Net::SSLeay::P_X509_get_key_usage", XS_Net__SSLeay_P_X509_get_key_usage, file, "$");
        (void)newXSproto_portable("Net::SSLeay::P_X509_get_netscape_cert_type", XS_Net__SSLeay_P_X509_get_netscape_cert_type, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_get_ext_by_NID", XS_Net__SSLeay_X509_get_ext_by_NID, file, "$$;$");
        (void)newXSproto_portable("Net::SSLeay::X509_get_ext", XS_Net__SSLeay_X509_get_ext, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_EXTENSION_get_critical", XS_Net__SSLeay_X509_EXTENSION_get_critical, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_EXTENSION_get_data", XS_Net__SSLeay_X509_EXTENSION_get_data, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_EXTENSION_get_object", XS_Net__SSLeay_X509_EXTENSION_get_object, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_get_ext_count", XS_Net__SSLeay_X509_get_ext_count, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_get_ext_count", XS_Net__SSLeay_X509_CRL_get_ext_count, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_get_ext_by_NID", XS_Net__SSLeay_X509_CRL_get_ext_by_NID, file, "$$;$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_get_ext", XS_Net__SSLeay_X509_CRL_get_ext, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509V3_EXT_print", XS_Net__SSLeay_X509V3_EXT_print, file, "$;$$");
        (void)newXSproto_portable("Net::SSLeay::X509V3_EXT_d2i", XS_Net__SSLeay_X509V3_EXT_d2i, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_STORE_CTX_get_error", XS_Net__SSLeay_X509_STORE_CTX_get_error, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_STORE_CTX_get_error_depth", XS_Net__SSLeay_X509_STORE_CTX_get_error_depth, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_STORE_CTX_set_ex_data", XS_Net__SSLeay_X509_STORE_CTX_set_ex_data, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::X509_STORE_CTX_set_error", XS_Net__SSLeay_X509_STORE_CTX_set_error, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_STORE_CTX_set_cert", XS_Net__SSLeay_X509_STORE_CTX_set_cert, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_STORE_add_cert", XS_Net__SSLeay_X509_STORE_add_cert, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_STORE_add_crl", XS_Net__SSLeay_X509_STORE_add_crl, file, "$$");
#if XSubPPtmpAAAS
        (void)newXSproto_portable("Net::SSLeay::X509_STORE_set_flags", XS_Net__SSLeay_X509_STORE_set_flags, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_STORE_set_purpose", XS_Net__SSLeay_X509_STORE_set_purpose, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_STORE_set_trust", XS_Net__SSLeay_X509_STORE_set_trust, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_STORE_set1_param", XS_Net__SSLeay_X509_STORE_set1_param, file, "$$");
#endif
        (void)newXSproto_portable("Net::SSLeay::X509_load_cert_file", XS_Net__SSLeay_X509_load_cert_file, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::X509_load_crl_file", XS_Net__SSLeay_X509_load_crl_file, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::X509_load_cert_crl_file", XS_Net__SSLeay_X509_load_cert_crl_file, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::X509_verify_cert_error_string", XS_Net__SSLeay_X509_verify_cert_error_string, file, "$");
        (void)newXSproto_portable("Net::SSLeay::ASN1_INTEGER_new", XS_Net__SSLeay_ASN1_INTEGER_new, file, "");
        (void)newXSproto_portable("Net::SSLeay::ASN1_INTEGER_free", XS_Net__SSLeay_ASN1_INTEGER_free, file, "$");
        (void)newXSproto_portable("Net::SSLeay::ASN1_INTEGER_set", XS_Net__SSLeay_ASN1_INTEGER_set, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::ASN1_INTEGER_get", XS_Net__SSLeay_ASN1_INTEGER_get, file, "$");
        (void)newXSproto_portable("Net::SSLeay::P_ASN1_INTEGER_set_hex", XS_Net__SSLeay_P_ASN1_INTEGER_set_hex, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::P_ASN1_INTEGER_set_dec", XS_Net__SSLeay_P_ASN1_INTEGER_set_dec, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::P_ASN1_INTEGER_get_hex", XS_Net__SSLeay_P_ASN1_INTEGER_get_hex, file, "$");
        (void)newXSproto_portable("Net::SSLeay::P_ASN1_INTEGER_get_dec", XS_Net__SSLeay_P_ASN1_INTEGER_get_dec, file, "$");
        (void)newXSproto_portable("Net::SSLeay::P_ASN1_STRING_get", XS_Net__SSLeay_P_ASN1_STRING_get, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::X509_get_notBefore", XS_Net__SSLeay_X509_get_notBefore, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_get_notAfter", XS_Net__SSLeay_X509_get_notAfter, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_gmtime_adj", XS_Net__SSLeay_X509_gmtime_adj, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::ASN1_TIME_set", XS_Net__SSLeay_ASN1_TIME_set, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::ASN1_TIME_free", XS_Net__SSLeay_ASN1_TIME_free, file, "$");
        (void)newXSproto_portable("Net::SSLeay::ASN1_TIME_new", XS_Net__SSLeay_ASN1_TIME_new, file, "");
        cv = newXSproto_portable("Net::SSLeay::P_ASN1_UTCTIME_put2string", XS_Net__SSLeay_P_ASN1_TIME_put2string, file, "$");
        XSANY.any_i32 = 1 ;
        cv = newXSproto_portable("Net::SSLeay::P_ASN1_TIME_put2string", XS_Net__SSLeay_P_ASN1_TIME_put2string, file, "$");
        XSANY.any_i32 = 0 ;
#if XSubPPtmpAAAT
        (void)newXSproto_portable("Net::SSLeay::P_ASN1_TIME_get_isotime", XS_Net__SSLeay_P_ASN1_TIME_get_isotime, file, "$");
        (void)newXSproto_portable("Net::SSLeay::P_ASN1_TIME_set_isotime", XS_Net__SSLeay_P_ASN1_TIME_set_isotime, file, "$$");
#endif
        (void)newXSproto_portable("Net::SSLeay::EVP_PKEY_copy_parameters", XS_Net__SSLeay_EVP_PKEY_copy_parameters, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::EVP_PKEY_new", XS_Net__SSLeay_EVP_PKEY_new, file, "");
        (void)newXSproto_portable("Net::SSLeay::EVP_PKEY_free", XS_Net__SSLeay_EVP_PKEY_free, file, "$");
        (void)newXSproto_portable("Net::SSLeay::EVP_PKEY_assign_RSA", XS_Net__SSLeay_EVP_PKEY_assign_RSA, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::EVP_PKEY_bits", XS_Net__SSLeay_EVP_PKEY_bits, file, "$");
        (void)newXSproto_portable("Net::SSLeay::EVP_PKEY_size", XS_Net__SSLeay_EVP_PKEY_size, file, "$");
#if XSubPPtmpAAAU
        (void)newXSproto_portable("Net::SSLeay::EVP_PKEY_id", XS_Net__SSLeay_EVP_PKEY_id, file, "$");
#endif
        (void)newXSproto_portable("Net::SSLeay::PEM_get_string_X509", XS_Net__SSLeay_PEM_get_string_X509, file, "$");
        (void)newXSproto_portable("Net::SSLeay::PEM_get_string_X509_REQ", XS_Net__SSLeay_PEM_get_string_X509_REQ, file, "$");
        (void)newXSproto_portable("Net::SSLeay::PEM_get_string_X509_CRL", XS_Net__SSLeay_PEM_get_string_X509_CRL, file, "$");
        (void)newXSproto_portable("Net::SSLeay::PEM_get_string_PrivateKey", XS_Net__SSLeay_PEM_get_string_PrivateKey, file, "$;$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_use_PKCS12_file", XS_Net__SSLeay_CTX_use_PKCS12_file, file, "$$;$");
        (void)newXSproto_portable("Net::SSLeay::P_PKCS12_load_file", XS_Net__SSLeay_P_PKCS12_load_file, file, "$;$$");
#if XSubPPtmpAAAV
        (void)newXSproto_portable("Net::SSLeay::MD2", XS_Net__SSLeay_MD2, file, "$");
#endif
        (void)newXSproto_portable("Net::SSLeay::MD4", XS_Net__SSLeay_MD4, file, "$");
        (void)newXSproto_portable("Net::SSLeay::MD5", XS_Net__SSLeay_MD5, file, "$");
#if XSubPPtmpAAAW
        (void)newXSproto_portable("Net::SSLeay::RIPEMD160", XS_Net__SSLeay_RIPEMD160, file, "$");
#endif
#if XSubPPtmpAAAX
        (void)newXSproto_portable("Net::SSLeay::SHA1", XS_Net__SSLeay_SHA1, file, "$");
#endif
#if XSubPPtmpAAAY
        (void)newXSproto_portable("Net::SSLeay::SHA256", XS_Net__SSLeay_SHA256, file, "$");
#endif
#if XSubPPtmpAAAZ
        (void)newXSproto_portable("Net::SSLeay::SHA512", XS_Net__SSLeay_SHA512, file, "$");
#endif
#if XSubPPtmpAABA
        (void)newXSproto_portable("Net::SSLeay::SSLv2_method", XS_Net__SSLeay_SSLv2_method, file, "");
#endif
        (void)newXSproto_portable("Net::SSLeay::SSLv3_method", XS_Net__SSLeay_SSLv3_method, file, "");
        (void)newXSproto_portable("Net::SSLeay::TLSv1_method", XS_Net__SSLeay_TLSv1_method, file, "");
#if XSubPPtmpAABB
        (void)newXSproto_portable("Net::SSLeay::TLSv1_1_method", XS_Net__SSLeay_TLSv1_1_method, file, "");
#endif
#if XSubPPtmpAABC
        (void)newXSproto_portable("Net::SSLeay::TLSv1_2_method", XS_Net__SSLeay_TLSv1_2_method, file, "");
#endif
#if XSubPPtmpAABD
        (void)newXSproto_portable("Net::SSLeay::set_ssl_method", XS_Net__SSLeay_set_ssl_method, file, "$$");
#endif
#if XSubPPtmpAABE
        (void)newXSproto_portable("Net::SSLeay::set_ssl_method", XS_Net__SSLeay_set_ssl_method, file, "$$");
#endif
        (void)newXSproto_portable("Net::SSLeay::get_ssl_method", XS_Net__SSLeay_get_ssl_method, file, "$");
        (void)newXSproto_portable("Net::SSLeay::BIO_new_buffer_ssl_connect", XS_Net__SSLeay_BIO_new_buffer_ssl_connect, file, "$");
        (void)newXSproto_portable("Net::SSLeay::BIO_new_file", XS_Net__SSLeay_BIO_new_file, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::BIO_new_ssl", XS_Net__SSLeay_BIO_new_ssl, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::BIO_new_ssl_connect", XS_Net__SSLeay_BIO_new_ssl_connect, file, "$");
        (void)newXSproto_portable("Net::SSLeay::BIO_new", XS_Net__SSLeay_BIO_new, file, "$");
        (void)newXSproto_portable("Net::SSLeay::BIO_free", XS_Net__SSLeay_BIO_free, file, "$");
        (void)newXSproto_portable("Net::SSLeay::BIO_read", XS_Net__SSLeay_BIO_read, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::BIO_write", XS_Net__SSLeay_BIO_write, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::BIO_eof", XS_Net__SSLeay_BIO_eof, file, "$");
        (void)newXSproto_portable("Net::SSLeay::BIO_pending", XS_Net__SSLeay_BIO_pending, file, "$");
        (void)newXSproto_portable("Net::SSLeay::BIO_wpending", XS_Net__SSLeay_BIO_wpending, file, "$");
        (void)newXSproto_portable("Net::SSLeay::BIO_ssl_copy_session_id", XS_Net__SSLeay_BIO_ssl_copy_session_id, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::BIO_ssl_shutdown", XS_Net__SSLeay_BIO_ssl_shutdown, file, "$");
        (void)newXSproto_portable("Net::SSLeay::add_client_CA", XS_Net__SSLeay_add_client_CA, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::alert_desc_string", XS_Net__SSLeay_alert_desc_string, file, "$");
        (void)newXSproto_portable("Net::SSLeay::alert_desc_string_long", XS_Net__SSLeay_alert_desc_string_long, file, "$");
        (void)newXSproto_portable("Net::SSLeay::alert_type_string", XS_Net__SSLeay_alert_type_string, file, "$");
        (void)newXSproto_portable("Net::SSLeay::alert_type_string_long", XS_Net__SSLeay_alert_type_string_long, file, "$");
        (void)newXSproto_portable("Net::SSLeay::callback_ctrl", XS_Net__SSLeay_callback_ctrl, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::check_private_key", XS_Net__SSLeay_check_private_key, file, "$");
#if XSubPPtmpAABF
        (void)newXSproto_portable("Net::SSLeay::CIPHER_description", XS_Net__SSLeay_CIPHER_description, file, "$$$");
#endif
#if XSubPPtmpAABG
        (void)newXSproto_portable("Net::SSLeay::CIPHER_description", XS_Net__SSLeay_CIPHER_description, file, "$$$");
#endif
#if XSubPPtmpAABH
        (void)newXSproto_portable("Net::SSLeay::CIPHER_get_name", XS_Net__SSLeay_CIPHER_get_name, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CIPHER_get_bits", XS_Net__SSLeay_CIPHER_get_bits, file, "$;$");
#endif
#if XSubPPtmpAABI
        (void)newXSproto_portable("Net::SSLeay::CIPHER_get_name", XS_Net__SSLeay_CIPHER_get_name, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CIPHER_get_bits", XS_Net__SSLeay_CIPHER_get_bits, file, "$;$");
#endif
        (void)newXSproto_portable("Net::SSLeay::COMP_add_compression_method", XS_Net__SSLeay_COMP_add_compression_method, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_add_client_CA", XS_Net__SSLeay_CTX_add_client_CA, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_callback_ctrl", XS_Net__SSLeay_CTX_callback_ctrl, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_check_private_key", XS_Net__SSLeay_CTX_check_private_key, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_get_ex_data", XS_Net__SSLeay_CTX_get_ex_data, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_get_quiet_shutdown", XS_Net__SSLeay_CTX_get_quiet_shutdown, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_get_timeout", XS_Net__SSLeay_CTX_get_timeout, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_get_verify_depth", XS_Net__SSLeay_CTX_get_verify_depth, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_get_verify_mode", XS_Net__SSLeay_CTX_get_verify_mode, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_cert_store", XS_Net__SSLeay_CTX_set_cert_store, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_get_cert_store", XS_Net__SSLeay_CTX_get_cert_store, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_cert_verify_callback", XS_Net__SSLeay_CTX_set_cert_verify_callback, file, "$$;$");
        (void)newXSproto_portable("Net::SSLeay::CTX_get_client_CA_list", XS_Net__SSLeay_CTX_get_client_CA_list, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_client_CA_list", XS_Net__SSLeay_CTX_set_client_CA_list, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_default_passwd_cb", XS_Net__SSLeay_CTX_set_default_passwd_cb, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_default_passwd_cb_userdata", XS_Net__SSLeay_CTX_set_default_passwd_cb_userdata, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_ex_data", XS_Net__SSLeay_CTX_set_ex_data, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_purpose", XS_Net__SSLeay_CTX_set_purpose, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_quiet_shutdown", XS_Net__SSLeay_CTX_set_quiet_shutdown, file, "$$");
#if XSubPPtmpAABJ
        (void)newXSproto_portable("Net::SSLeay::CTX_set_ssl_version", XS_Net__SSLeay_CTX_set_ssl_version, file, "$$");
#endif
#if XSubPPtmpAABK
        (void)newXSproto_portable("Net::SSLeay::CTX_set_ssl_version", XS_Net__SSLeay_CTX_set_ssl_version, file, "$$");
#endif
        (void)newXSproto_portable("Net::SSLeay::CTX_set_timeout", XS_Net__SSLeay_CTX_set_timeout, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_trust", XS_Net__SSLeay_CTX_set_trust, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_verify_depth", XS_Net__SSLeay_CTX_set_verify_depth, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_use_certificate", XS_Net__SSLeay_CTX_use_certificate, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_use_certificate_chain_file", XS_Net__SSLeay_CTX_use_certificate_chain_file, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_use_PrivateKey", XS_Net__SSLeay_CTX_use_PrivateKey, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_use_RSAPrivateKey", XS_Net__SSLeay_CTX_use_RSAPrivateKey, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::do_handshake", XS_Net__SSLeay_do_handshake, file, "$");
        (void)newXSproto_portable("Net::SSLeay::dup", XS_Net__SSLeay_dup, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_current_cipher", XS_Net__SSLeay_get_current_cipher, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_default_timeout", XS_Net__SSLeay_get_default_timeout, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_ex_data", XS_Net__SSLeay_get_ex_data, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::get_finished", XS_Net__SSLeay_get_finished, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::get_peer_finished", XS_Net__SSLeay_get_peer_finished, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::get_quiet_shutdown", XS_Net__SSLeay_get_quiet_shutdown, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_shutdown", XS_Net__SSLeay_get_shutdown, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_verify_depth", XS_Net__SSLeay_get_verify_depth, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_verify_mode", XS_Net__SSLeay_get_verify_mode, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_verify_result", XS_Net__SSLeay_get_verify_result, file, "$");
        (void)newXSproto_portable("Net::SSLeay::renegotiate", XS_Net__SSLeay_renegotiate, file, "$");
#if XSubPPtmpAABL
        (void)newXSproto_portable("Net::SSLeay::SESSION_cmp", XS_Net__SSLeay_SESSION_cmp, file, "$$");
#endif
        (void)newXSproto_portable("Net::SSLeay::SESSION_get_ex_data", XS_Net__SSLeay_SESSION_get_ex_data, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::SESSION_get_time", XS_Net__SSLeay_SESSION_get_time, file, "$");
        (void)newXSproto_portable("Net::SSLeay::SESSION_get_timeout", XS_Net__SSLeay_SESSION_get_timeout, file, "$");
        (void)newXSproto_portable("Net::SSLeay::SESSION_print_fp", XS_Net__SSLeay_SESSION_print_fp, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::SESSION_set_ex_data", XS_Net__SSLeay_SESSION_set_ex_data, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::SESSION_set_time", XS_Net__SSLeay_SESSION_set_time, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::SESSION_set_timeout", XS_Net__SSLeay_SESSION_set_timeout, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_accept_state", XS_Net__SSLeay_set_accept_state, file, "$");
        (void)newXSproto_portable("Net::SSLeay::sk_X509_NAME_free", XS_Net__SSLeay_sk_X509_NAME_free, file, "$");
        (void)newXSproto_portable("Net::SSLeay::sk_X509_NAME_num", XS_Net__SSLeay_sk_X509_NAME_num, file, "$");
        (void)newXSproto_portable("Net::SSLeay::sk_X509_NAME_value", XS_Net__SSLeay_sk_X509_NAME_value, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::get_client_CA_list", XS_Net__SSLeay_get_client_CA_list, file, "$");
        (void)newXSproto_portable("Net::SSLeay::set_client_CA_list", XS_Net__SSLeay_set_client_CA_list, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_connect_state", XS_Net__SSLeay_set_connect_state, file, "$");
        (void)newXSproto_portable("Net::SSLeay::set_ex_data", XS_Net__SSLeay_set_ex_data, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::set_info_callback", XS_Net__SSLeay_set_info_callback, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_purpose", XS_Net__SSLeay_set_purpose, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_quiet_shutdown", XS_Net__SSLeay_set_quiet_shutdown, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_shutdown", XS_Net__SSLeay_set_shutdown, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_trust", XS_Net__SSLeay_set_trust, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_verify_depth", XS_Net__SSLeay_set_verify_depth, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_verify_result", XS_Net__SSLeay_set_verify_result, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::shutdown", XS_Net__SSLeay_shutdown, file, "$");
        (void)newXSproto_portable("Net::SSLeay::version", XS_Net__SSLeay_version, file, "$");
        (void)newXSproto_portable("Net::SSLeay::load_client_CA_file", XS_Net__SSLeay_load_client_CA_file, file, "$");
        (void)newXSproto_portable("Net::SSLeay::add_file_cert_subjects_to_stack", XS_Net__SSLeay_add_file_cert_subjects_to_stack, file, "$$");
#if XSubPPtmpAABM
        (void)newXSproto_portable("Net::SSLeay::add_dir_cert_subjects_to_stack", XS_Net__SSLeay_add_dir_cert_subjects_to_stack, file, "$$");
#endif
        (void)newXSproto_portable("Net::SSLeay::CTX_get_ex_new_index", XS_Net__SSLeay_CTX_get_ex_new_index, file, "$$$$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_session_id_context", XS_Net__SSLeay_CTX_set_session_id_context, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::set_session_id_context", XS_Net__SSLeay_set_session_id_context, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_tmp_rsa_callback", XS_Net__SSLeay_CTX_set_tmp_rsa_callback, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_tmp_rsa_callback", XS_Net__SSLeay_set_tmp_rsa_callback, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_tmp_dh_callback", XS_Net__SSLeay_CTX_set_tmp_dh_callback, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_tmp_dh_callback", XS_Net__SSLeay_set_tmp_dh_callback, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::get_ex_new_index", XS_Net__SSLeay_get_ex_new_index, file, "$$$$$");
        (void)newXSproto_portable("Net::SSLeay::SESSION_get_ex_new_index", XS_Net__SSLeay_SESSION_get_ex_new_index, file, "$$$$$");
        (void)newXSproto_portable("Net::SSLeay::clear_num_renegotiations", XS_Net__SSLeay_clear_num_renegotiations, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_add_extra_chain_cert", XS_Net__SSLeay_CTX_add_extra_chain_cert, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_get_app_data", XS_Net__SSLeay_CTX_get_app_data, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_get_mode", XS_Net__SSLeay_CTX_get_mode, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_get_read_ahead", XS_Net__SSLeay_CTX_get_read_ahead, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_get_session_cache_mode", XS_Net__SSLeay_CTX_get_session_cache_mode, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_need_tmp_RSA", XS_Net__SSLeay_CTX_need_tmp_RSA, file, "$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_app_data", XS_Net__SSLeay_CTX_set_app_data, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_mode", XS_Net__SSLeay_CTX_set_mode, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_read_ahead", XS_Net__SSLeay_CTX_set_read_ahead, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_session_cache_mode", XS_Net__SSLeay_CTX_set_session_cache_mode, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_tmp_dh", XS_Net__SSLeay_CTX_set_tmp_dh, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_tmp_rsa", XS_Net__SSLeay_CTX_set_tmp_rsa, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::get_app_data", XS_Net__SSLeay_get_app_data, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_cipher_bits", XS_Net__SSLeay_get_cipher_bits, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::get_mode", XS_Net__SSLeay_get_mode, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_state", XS_Net__SSLeay_get_state, file, "$");
        (void)newXSproto_portable("Net::SSLeay::need_tmp_RSA", XS_Net__SSLeay_need_tmp_RSA, file, "$");
        (void)newXSproto_portable("Net::SSLeay::num_renegotiations", XS_Net__SSLeay_num_renegotiations, file, "$");
        (void)newXSproto_portable("Net::SSLeay::SESSION_get_app_data", XS_Net__SSLeay_SESSION_get_app_data, file, "$");
        (void)newXSproto_portable("Net::SSLeay::session_reused", XS_Net__SSLeay_session_reused, file, "$");
        (void)newXSproto_portable("Net::SSLeay::SESSION_set_app_data", XS_Net__SSLeay_SESSION_set_app_data, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_app_data", XS_Net__SSLeay_set_app_data, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_mode", XS_Net__SSLeay_set_mode, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_pref_cipher", XS_Net__SSLeay_set_pref_cipher, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_tmp_dh", XS_Net__SSLeay_set_tmp_dh, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set_tmp_rsa", XS_Net__SSLeay_set_tmp_rsa, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::RSA_generate_key", XS_Net__SSLeay_RSA_generate_key, file, "$$;$$");
        (void)newXSproto_portable("Net::SSLeay::RSA_free", XS_Net__SSLeay_RSA_free, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_new", XS_Net__SSLeay_X509_new, file, "");
        (void)newXSproto_portable("Net::SSLeay::X509_free", XS_Net__SSLeay_X509_free, file, "$");
        (void)newXSproto_portable("Net::SSLeay::d2i_X509_CRL_bio", XS_Net__SSLeay_d2i_X509_CRL_bio, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::d2i_X509_REQ_bio", XS_Net__SSLeay_d2i_X509_REQ_bio, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::d2i_X509_bio", XS_Net__SSLeay_d2i_X509_bio, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::PEM_read_bio_DHparams", XS_Net__SSLeay_PEM_read_bio_DHparams, file, "$;$$$");
        (void)newXSproto_portable("Net::SSLeay::PEM_read_bio_X509_CRL", XS_Net__SSLeay_PEM_read_bio_X509_CRL, file, "$;$$$");
        (void)newXSproto_portable("Net::SSLeay::PEM_read_bio_X509", XS_Net__SSLeay_PEM_read_bio_X509, file, "$;$$$");
        (void)newXSproto_portable("Net::SSLeay::PEM_read_bio_X509_REQ", XS_Net__SSLeay_PEM_read_bio_X509_REQ, file, "$;$$$");
        (void)newXSproto_portable("Net::SSLeay::PEM_read_bio_PrivateKey", XS_Net__SSLeay_PEM_read_bio_PrivateKey, file, "$;$$");
        (void)newXSproto_portable("Net::SSLeay::DH_free", XS_Net__SSLeay_DH_free, file, "$");
        (void)newXSproto_portable("Net::SSLeay::total_renegotiations", XS_Net__SSLeay_total_renegotiations, file, "$");
        (void)newXSproto_portable("Net::SSLeay::SESSION_get_master_key", XS_Net__SSLeay_SESSION_get_master_key, file, "$");
        (void)newXSproto_portable("Net::SSLeay::SESSION_set_master_key", XS_Net__SSLeay_SESSION_set_master_key, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::get_client_random", XS_Net__SSLeay_get_client_random, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_server_random", XS_Net__SSLeay_get_server_random, file, "$");
        (void)newXSproto_portable("Net::SSLeay::get_keyblock_size", XS_Net__SSLeay_get_keyblock_size, file, "$");
#if XSubPPtmpAABN
        (void)newXSproto_portable("Net::SSLeay::set_hello_extension", XS_Net__SSLeay_set_hello_extension, file, "$$$");
#endif
#if XSubPPtmpAABO
        (void)newXSproto_portable("Net::SSLeay::set_session_secret_cb", XS_Net__SSLeay_set_session_secret_cb, file, "$;$$");
#endif
#if XSubPPtmpAABP
        (void)newXSproto_portable("Net::SSLeay::EVP_add_digest", XS_Net__SSLeay_EVP_add_digest, file, "$");
#endif
#if XSubPPtmpAABQ
        (void)newXSproto_portable("Net::SSLeay::EVP_add_digest", XS_Net__SSLeay_EVP_add_digest, file, "$");
#endif
#if XSubPPtmpAABR
        (void)newXSproto_portable("Net::SSLeay::EVP_sha1", XS_Net__SSLeay_EVP_sha1, file, "");
#endif
#if XSubPPtmpAABS
        (void)newXSproto_portable("Net::SSLeay::EVP_sha256", XS_Net__SSLeay_EVP_sha256, file, "");
#endif
#if XSubPPtmpAABT
        (void)newXSproto_portable("Net::SSLeay::EVP_sha512", XS_Net__SSLeay_EVP_sha512, file, "");
#endif
        (void)newXSproto_portable("Net::SSLeay::OpenSSL_add_all_digests", XS_Net__SSLeay_OpenSSL_add_all_digests, file, "");
        (void)newXSproto_portable("Net::SSLeay::EVP_get_digestbyname", XS_Net__SSLeay_EVP_get_digestbyname, file, "$");
        (void)newXSproto_portable("Net::SSLeay::EVP_MD_type", XS_Net__SSLeay_EVP_MD_type, file, "$");
        (void)newXSproto_portable("Net::SSLeay::EVP_MD_size", XS_Net__SSLeay_EVP_MD_size, file, "$");
#if XSubPPtmpAABU
        (void)newXSproto_portable("Net::SSLeay::P_EVP_MD_list_all", XS_Net__SSLeay_P_EVP_MD_list_all, file, "");
#endif
#if XSubPPtmpAABV
        (void)newXSproto_portable("Net::SSLeay::EVP_MD_CTX_md", XS_Net__SSLeay_EVP_MD_CTX_md, file, "$");
        (void)newXSproto_portable("Net::SSLeay::EVP_MD_CTX_create", XS_Net__SSLeay_EVP_MD_CTX_create, file, "");
        (void)newXSproto_portable("Net::SSLeay::EVP_DigestInit", XS_Net__SSLeay_EVP_DigestInit, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::EVP_DigestInit_ex", XS_Net__SSLeay_EVP_DigestInit_ex, file, "$$$");
        (void)newXSproto_portable("Net::SSLeay::EVP_MD_CTX_destroy", XS_Net__SSLeay_EVP_MD_CTX_destroy, file, "$");
        (void)newXSproto_portable("Net::SSLeay::EVP_DigestUpdate", XS_Net__SSLeay_EVP_DigestUpdate, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::EVP_DigestFinal", XS_Net__SSLeay_EVP_DigestFinal, file, "$");
        (void)newXSproto_portable("Net::SSLeay::EVP_DigestFinal_ex", XS_Net__SSLeay_EVP_DigestFinal_ex, file, "$");
        (void)newXSproto_portable("Net::SSLeay::EVP_Digest", XS_Net__SSLeay_EVP_Digest, file, ";@");
#endif
        (void)newXSproto_portable("Net::SSLeay::EVP_get_cipherbyname", XS_Net__SSLeay_EVP_get_cipherbyname, file, "$");
        (void)newXSproto_portable("Net::SSLeay::OpenSSL_add_all_algorithms", XS_Net__SSLeay_OpenSSL_add_all_algorithms, file, "");
#if XSubPPtmpAABW
        (void)newXSproto_portable("Net::SSLeay::OPENSSL_add_all_algorithms_noconf", XS_Net__SSLeay_OPENSSL_add_all_algorithms_noconf, file, "");
        (void)newXSproto_portable("Net::SSLeay::OPENSSL_add_all_algorithms_conf", XS_Net__SSLeay_OPENSSL_add_all_algorithms_conf, file, "");
#endif
#if XSubPPtmpAABX
        (void)newXSproto_portable("Net::SSLeay::CTX_set1_param", XS_Net__SSLeay_CTX_set1_param, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::set1_param", XS_Net__SSLeay_set1_param, file, "$$");
#endif
#if XSubPPtmpAABY
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_new", XS_Net__SSLeay_X509_VERIFY_PARAM_new, file, "");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_free", XS_Net__SSLeay_X509_VERIFY_PARAM_free, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_inherit", XS_Net__SSLeay_X509_VERIFY_PARAM_inherit, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_set1", XS_Net__SSLeay_X509_VERIFY_PARAM_set1, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_set1_name", XS_Net__SSLeay_X509_VERIFY_PARAM_set1_name, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_set_flags", XS_Net__SSLeay_X509_VERIFY_PARAM_set_flags, file, "$$");
#if XSubPPtmpAABZ
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_clear_flags", XS_Net__SSLeay_X509_VERIFY_PARAM_clear_flags, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_get_flags", XS_Net__SSLeay_X509_VERIFY_PARAM_get_flags, file, "$");
#endif
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_set_purpose", XS_Net__SSLeay_X509_VERIFY_PARAM_set_purpose, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_set_trust", XS_Net__SSLeay_X509_VERIFY_PARAM_set_trust, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_set_depth", XS_Net__SSLeay_X509_VERIFY_PARAM_set_depth, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_set_time", XS_Net__SSLeay_X509_VERIFY_PARAM_set_time, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_add0_policy", XS_Net__SSLeay_X509_VERIFY_PARAM_add0_policy, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_set1_policies", XS_Net__SSLeay_X509_VERIFY_PARAM_set1_policies, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_get_depth", XS_Net__SSLeay_X509_VERIFY_PARAM_get_depth, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_add0_table", XS_Net__SSLeay_X509_VERIFY_PARAM_add0_table, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_lookup", XS_Net__SSLeay_X509_VERIFY_PARAM_lookup, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_VERIFY_PARAM_table_cleanup", XS_Net__SSLeay_X509_VERIFY_PARAM_table_cleanup, file, "");
        (void)newXSproto_portable("Net::SSLeay::X509_policy_tree_free", XS_Net__SSLeay_X509_policy_tree_free, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_policy_tree_level_count", XS_Net__SSLeay_X509_policy_tree_level_count, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_policy_tree_get0_level", XS_Net__SSLeay_X509_policy_tree_get0_level, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_policy_tree_get0_policies", XS_Net__SSLeay_X509_policy_tree_get0_policies, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_policy_tree_get0_user_policies", XS_Net__SSLeay_X509_policy_tree_get0_user_policies, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_policy_level_node_count", XS_Net__SSLeay_X509_policy_level_node_count, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_policy_level_get0_node", XS_Net__SSLeay_X509_policy_level_get0_node, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_policy_node_get0_policy", XS_Net__SSLeay_X509_policy_node_get0_policy, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_policy_node_get0_qualifiers", XS_Net__SSLeay_X509_policy_node_get0_qualifiers, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_policy_node_get0_parent", XS_Net__SSLeay_X509_policy_node_get0_parent, file, "$");
#endif
        (void)newXSproto_portable("Net::SSLeay::OBJ_dup", XS_Net__SSLeay_OBJ_dup, file, "$");
        (void)newXSproto_portable("Net::SSLeay::OBJ_nid2obj", XS_Net__SSLeay_OBJ_nid2obj, file, "$");
        (void)newXSproto_portable("Net::SSLeay::OBJ_nid2ln", XS_Net__SSLeay_OBJ_nid2ln, file, "$");
        (void)newXSproto_portable("Net::SSLeay::OBJ_nid2sn", XS_Net__SSLeay_OBJ_nid2sn, file, "$");
        (void)newXSproto_portable("Net::SSLeay::OBJ_obj2nid", XS_Net__SSLeay_OBJ_obj2nid, file, "$");
        (void)newXSproto_portable("Net::SSLeay::OBJ_txt2obj", XS_Net__SSLeay_OBJ_txt2obj, file, "$;$");
        (void)newXSproto_portable("Net::SSLeay::OBJ_obj2txt", XS_Net__SSLeay_OBJ_obj2txt, file, "$;$");
#if XSubPPtmpAACA
        (void)newXSproto_portable("Net::SSLeay::OBJ_txt2nid", XS_Net__SSLeay_OBJ_txt2nid, file, "$");
#endif
#if XSubPPtmpAACB
        (void)newXSproto_portable("Net::SSLeay::OBJ_txt2nid", XS_Net__SSLeay_OBJ_txt2nid, file, "$");
#endif
        (void)newXSproto_portable("Net::SSLeay::OBJ_ln2nid", XS_Net__SSLeay_OBJ_ln2nid, file, "$");
        (void)newXSproto_portable("Net::SSLeay::OBJ_sn2nid", XS_Net__SSLeay_OBJ_sn2nid, file, "$");
        (void)newXSproto_portable("Net::SSLeay::OBJ_cmp", XS_Net__SSLeay_OBJ_cmp, file, "$$");
#if XSubPPtmpAACC
        (void)newXSproto_portable("Net::SSLeay::X509_pubkey_digest", XS_Net__SSLeay_X509_pubkey_digest, file, "$$");
#endif
        (void)newXSproto_portable("Net::SSLeay::X509_digest", XS_Net__SSLeay_X509_digest, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_CRL_digest", XS_Net__SSLeay_X509_CRL_digest, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_REQ_digest", XS_Net__SSLeay_X509_REQ_digest, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_NAME_digest", XS_Net__SSLeay_X509_NAME_digest, file, "$$");
        (void)newXSproto_portable("Net::SSLeay::X509_subject_name_hash", XS_Net__SSLeay_X509_subject_name_hash, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_issuer_name_hash", XS_Net__SSLeay_X509_issuer_name_hash, file, "$");
        (void)newXSproto_portable("Net::SSLeay::X509_issuer_and_serial_hash", XS_Net__SSLeay_X509_issuer_and_serial_hash, file, "$");
        (void)newXSproto_portable("Net::SSLeay::P_X509_get_signature_alg", XS_Net__SSLeay_P_X509_get_signature_alg, file, "$");
        (void)newXSproto_portable("Net::SSLeay::P_X509_get_pubkey_alg", XS_Net__SSLeay_P_X509_get_pubkey_alg, file, "$");
#if XSubPPtmpAACD
        (void)newXSproto_portable("Net::SSLeay::CTX_set_next_protos_advertised_cb", XS_Net__SSLeay_CTX_set_next_protos_advertised_cb, file, "$$;$");
        (void)newXSproto_portable("Net::SSLeay::CTX_set_next_proto_select_cb", XS_Net__SSLeay_CTX_set_next_proto_select_cb, file, "$$;$");
        (void)newXSproto_portable("Net::SSLeay::P_next_proto_negotiated", XS_Net__SSLeay_P_next_proto_negotiated, file, "$");
        (void)newXSproto_portable("Net::SSLeay::P_next_proto_last_status", XS_Net__SSLeay_P_next_proto_last_status, file, "$");
#endif
#if XSubPPtmpAACE
        (void)newXSproto_portable("Net::SSLeay::export_keying_material", XS_Net__SSLeay_export_keying_material, file, "$$$$");
#endif
#if XSubPPtmpAACF
        (void)newXSproto_portable("Net::SSLeay::get_tlsa_record_byname", XS_Net__SSLeay_get_tlsa_record_byname, file, "$$$");
#endif
    }

    /* Initialisation Section */

#line 1019 "SSLeay.xs"
    {
    MY_CXT_INIT;
    LIB_initialized = 0;
#ifdef USE_ITHREADS
    MUTEX_INIT(&LIB_init_mutex);
#ifdef OPENSSL_THREADS
    /* If we running under ModPerl, we dont need our own thread locking because
     * perl threads are not supported under mod-perl, and we can fall back to the thread
     * locking built in to mod-ssl      
     */
     if (!hv_fetch(get_hv("ENV", 1), "MOD_PERL", 8, 0))
	openssl_threads_init();
#endif
#endif
    /* initialize global shared callback data hash */
    MY_CXT.global_cb_data = newHV();
    MY_CXT.tid = get_my_thread_id();
    PR3("BOOT: tid=%d my_perl=0x%p\n", MY_CXT.tid, my_perl);
    }

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#if XSubPPtmpAAAI
#endif
#if XSubPPtmpAAAJ
#endif
#if XSubPPtmpAAAK
#endif
#if XSubPPtmpAAAL
#endif
#if XSubPPtmpAAAM
#endif
#if XSubPPtmpAAAN
#endif
#if XSubPPtmpAAAO
#endif
#if XSubPPtmpAAAP
#endif
#if XSubPPtmpAAAQ
#endif
#if XSubPPtmpAAAR
#endif
#if XSubPPtmpAAAS
#endif
#if XSubPPtmpAAAT
#endif
#if XSubPPtmpAAAU
#endif
#if XSubPPtmpAAAV
#endif
#if XSubPPtmpAAAW
#endif
#if XSubPPtmpAAAX
#endif
#if XSubPPtmpAAAY
#endif
#if XSubPPtmpAAAZ
#endif
#if XSubPPtmpAABA
#endif
#if XSubPPtmpAABB
#endif
#if XSubPPtmpAABC
#endif
#if XSubPPtmpAABD
#endif
#if XSubPPtmpAABE
#endif
#if XSubPPtmpAABF
#endif
#if XSubPPtmpAABG
#endif
#if XSubPPtmpAABH
#endif
#if XSubPPtmpAABI
#endif
#if XSubPPtmpAABJ
#endif
#if XSubPPtmpAABK
#endif
#if XSubPPtmpAABL
#endif
#if XSubPPtmpAABM
#endif
#if XSubPPtmpAABN
#endif
#if XSubPPtmpAABO
#endif
#if XSubPPtmpAABP
#endif
#if XSubPPtmpAABQ
#endif
#if XSubPPtmpAABR
#endif
#if XSubPPtmpAABS
#endif
#if XSubPPtmpAABT
#endif
#if XSubPPtmpAABU
#endif
#if XSubPPtmpAABV
#endif
#if XSubPPtmpAABW
#endif
#if XSubPPtmpAABX
#endif
#if XSubPPtmpAABY
#if XSubPPtmpAABZ
#endif
#endif
#if XSubPPtmpAACA
#endif
#if XSubPPtmpAACB
#endif
#if XSubPPtmpAACC
#endif
#if XSubPPtmpAACD
#endif
#if XSubPPtmpAACE
#endif
#if XSubPPtmpAACF
#endif
#line 15146 "SSLeay.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

